<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2018/03/07/title/"/>
      <content type="html"><![CDATA[<h1 id="淮中晚泊犊头"><a href="#淮中晚泊犊头" class="headerlink" title="淮中晚泊犊头"></a>淮中晚泊犊头</h1><h3 id="苏舜钦"><a href="#苏舜钦" class="headerlink" title="苏舜钦"></a>苏舜钦</h3><p>春阴垂野草青青，时有幽花一树明。</p><p>晚泊孤舟古祠下，满川风雨看潮生。</p>]]></content>
      
      <categories>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/07/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LinkedHashMap学习笔记</title>
      <link href="/2018/01/23/title2/"/>
      <content type="html"><![CDATA[<blockquote><p>前几天看到一篇关于面试问题的博客，里面提到LinkedHashMap和TreeMap区别于HashMap的地方有一点就是是否有序，当时不甚明白，因为觉得LinkedHashMap用的是链表结构的，不知道是如何实现有序的，所以去看了看源码和一些文章。</p></blockquote><hr><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>LinkedHashMap继承自HashMap，内部类Entry也是继承自HashMap.Node&lt;K,V&gt;，但是里面定义了两个独有的元素：<code>Entry&lt;K,V&gt; before, after;</code>，有序就是通过这两个元素来实现。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>LinkedHashMap实现的基本思想就是对<code>多态</code>的使用。它许多方法都是使用的HashMap中已有的方法，通过对方法中调用的子方法进行复写，通过动态绑定，实现方法重用。</p><h5 id="1-内部属性"><a href="#1-内部属性" class="headerlink" title="1.内部属性"></a>1.内部属性</h5><p>在我所看的1.8版本的jdk中，定义了一个静态节点元素Entry，以及这个链表的头元素head和尾元素tail，这两个元素是用来方便对链表进行操作的。</p><p>此外还有一个特有的属性<code>final boolean accessOrder</code>，这是一个用来确定LinkedHashMap的顺序的值，若初始化时确定为false代表按照插入顺序，true表示按照最后操作顺序。在调用构造方法进行初始化时，如果没有指定这个值，默认都是为false。而且构造方法都是调用父类的构造方法来实现的。</p><h5 id="2-有序实现"><a href="#2-有序实现" class="headerlink" title="2.有序实现"></a>2.有序实现</h5><p>我们在此先不讨论accessOrder为true的情况，单说按照插入顺序访问的实现方式。</p><p>刚才有提到Entry节点比父类中的多了两个指针，before和after，看到这两个指针时大概就能想到实现按照插入顺序的访问应该是在插入节点时记录他的before和after两个值。知道了它的大概方式，我们来找它的具体实现。</p><p>观察源码可以发现LinkedHashMap中关于元素存取，值重写了get方法，并没有重写put方法。之所以会重写get方法是因为要实现按照元素最后访问顺序的有序方式。我们来到父类HashMap中,当桶中相应位置没有元素时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure></p><p>当hash值对应位置有元素存在时，且新元素的key不跟其他元素相同时，在链表末尾将新元素加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line">if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">else &#123;</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, null);</span><br><span class="line">            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            break;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察代码发现新节点的加入使用的是newNode方法，这个方法在子类中是重写了的，所以会调用子类中的newNode方法，所以我们又回到了LinkedHashMap中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法会new一个Entry，通过linkNodeLast将其顺序确定下来，然后返回一个Entry类型的元素。所以其实有序的实现是放在了linkNodeLast这个方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用之前定义的tail来操作，新建一个last元素保存tail的引用，将传入的元素设置为最后一个，然后确定两个元素之间的指向问题。这样就将插入的顺序记录了下来。</p><p>另外，accessOrder=true的情况也是对这个指针的指向的修改，通过将最后访问的节点改到tail的位置，本文不作深入的探讨。</p><h5 id="3-迭代器遍历"><a href="#3-迭代器遍历" class="headerlink" title="3.迭代器遍历"></a>3.迭代器遍历</h5><p>LinkedHashMap内部定义了一个内部抽象类，LinkedHashIterator，里面定义了相关的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历时使用after来改变指向，就能够按照顺序来访问了。它的子类有LinkedKeyIterator，LinkedValueIterator，LinkedEntryIterator三个，都实现了Iterator接口，使用时能够自动根据数据类型动态绑定相应的方法进行遍历的实现。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedHashMap </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
