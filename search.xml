<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>volatile机制探究</title>
      <link href="/2018/04/01/180401/"/>
      <content type="html"><![CDATA[<blockquote><p>看了别人的几篇博客，觉得受益匪浅，同时有一点自己的想法，想记录下来，便有了这篇博文。<br><a id="more"></a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>多线程主要围绕的问题就是可见性，原子性和有序性这些特性。而使用volatile关键字修饰的变量，能够保证其在多线程之间的可见性，即每次读取到的volatile变量，一定是最新的数据。<br>volatile同时也会阻止进行语句重排。</p><p>从内存模型说起，在java虚拟机中，程序计数器 java虚拟机栈 本地方法栈都是线程私有的，方法区和java堆是线程公有的。各种数据在内存中存放的位置：</p><p>局部变量，是指在方法中定义的基本类型的变量和引用类型的指针，都在方法的栈内存中分配空间，当方法运行完成时，内存被施放。成员变量，在所在类未被初始化（能不能用初始化这个词？）时，作为类的字段信息存放在方法区中，类实例化成对象后，存放在堆中。静态变量（类变量）放在方法区中，常量存放在运行时常量池中（运行时常量池jdk1.7以后被放在了java堆中）</p><p>当java的线程需要对公有数据进行操作时，会将主内存中的数据拷贝到工作内存中再进行操作，执行成功后再将数据写回主内存中，这样的操作方式很容易发生在多个线程同时操作一个公有数据时，因为读写的不同步导致执行发生不可预料的错误，例如脏读。</p><p>在下面的这个示例程序中，有一个成员变量bChanged，这个变量会被一个线程不停修改，而在另一个线程中不做改动，只进行一个<code>bChanged==!bChanged</code>的判断。在没有使用volatile关键字时，<code>bChanged==!bChanged</code>判断的结果一直为<code>false</code>，不会执行任何输出。而当使用了volatile关键字修饰变量之后，会有输出出现。</p><p>这里只放有volatile的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DirtyRead &#123;</span><br><span class="line"></span><br><span class="line">public static volatile boolean bChanged = false;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">if(bChanged == !bChanged)&#123;</span><br><span class="line">System.out.println(&quot;bChanged == !bChanged&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">Thread.sleep(1);</span><br><span class="line">new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">bChanged = !bChanged;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行后的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bChanged == !bChanged</span><br><span class="line">bChanged == !bChanged</span><br><span class="line">bChanged == !bChanged</span><br><span class="line">bChanged == !bChanged</span><br><span class="line">···</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>做一个<code>bChanged == !bChanged</code>的判断竟然结果能为真，看起来很扯，但是其实这就是volatile这个关键字的作用。</p><p>两种特性：</p><ol><li>保证此变量对所有线程的可见性。即当某个线程修改了这个变量的值，这个新的值能够立刻同步到主内存中，且使其他线程中的缓存无效，其他线程使用这个值前会从主存刷新。（也就是说声明了volatile后，每次读变量的操作都是从内存中读，跳过了CPU cache）</li><li>禁止指令重排序优化。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>处理器为了提高处理速度，不直接和内存进行通讯，而是会将系统内存的数据读到内部缓存（CPU L1L2 cache或者其他）之后再进行操作，操作完成后写回到内存的时间不确定。</p><p>对声明了volatile的变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令（lock前缀的指令在多核处理器下会引发两件事，将当前处理器缓存行的数据写回到系统内存，这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效），将这个变量所在缓存行的数据写回系统内存。这一步就能够保证将对变量的修改更新到主存中。</p><p>但是这个时候其他处理器的缓存还是旧的，所以在多处理器的环境下，为了保证各个处理器缓存一致，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据堵到处理器缓存里。这一步保证了其他线程得到的变量都是新的。</p><p>这里参考了<a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">聊聊并发（一）深入分析Volatile的实现原理</a>中对底层原理的描述，但是因为还是挺繁琐的，就自己简化了一下描述，想了解完整内容的可以去这个网址看一看。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>但是volatile只保证有序性和可见性，比起其他的同步方式例如synchronouse少了一个原子性。他只能保证在读取这个变量使用时能够得到最新的数据，由于没有原子性，并不能保证在使用的过程中值不变。比如在上面的那个例子中，<code>bChanged == !bChanged</code>有时会被判断为true，就是因为在java的指令执行时，先取得了第一个bChanged的值放进内存，然后取第二个bChanged的值，在这两次操作之中，bChanged的值在另一个线程中发生了改变，于是读取出来的值也就发生了变化，就出现了上面的那种情况。</p><p>为了更好地说明他不具备原子性，写了下面这个例子来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">volatile int i = 0;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j = 0; j &lt; 10000; j++)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">VolatileDemo v = new VolatileDemo();</span><br><span class="line">Thread t1 = new Thread(v);</span><br><span class="line">Thread t2 = new Thread(v);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(&quot;the value of i :&quot;+v.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the value of i :12630</span><br></pre></td></tr></table></figure></p><p>虽然执行的结果有很大的随机性，但是多次执行以后发现这个值是远小于20000的。这就是因为<code>i++</code>这个操作不是原子操作，相当于<code>i = i + 1</code>，会进行取值、加一、赋值这几个操作，在他进入一次自增操作到自增结束的这段时间中，不会对主存中的数值进行修改，另一个线程在这个时间段中进行的自增操作读取的还是没有修改前的数值，导致这两次自增过后写入主存的是同一个值。就在报道上出现了偏差。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>由我的上一段话可以知道，volatile这个关键字只是一种轻量级的同步机制，并不具备锁的特性，虽然不会阻塞线程的执行，但是也没办法保证多线程之间的安全性。所以这个关键字具有和普通的锁不同的使用场景。</p><p>在需要使用volatile变量的地方，主要看重的是其简易性，在某些情况下，volatile变量要比使用相应的锁简单得多。其次是性能的原因，某些情况下，volatile变量同步机制的性能要优于锁。（之所以说是在“某些情况下”，是因为对于操作的具体开销，很难做出准确的评价，因为单纯进行volatile和synchronouse的比较是很难的。但是，因为我们能够了解到在大多数的处理器架构下，volatile的读操作开销非常低，写操作的开销更高，虽然还是比获取锁低。所以，当读操作的次数远大于写操作 的次数时，使用volatile是更好的选择）</p><p>使用volatile的场景的条件：</p><ol><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>通过这两个条件能得出一个结论，volatile适合用作对于变量当前状态的判断上，不能用来做多个线程之间的计数器。</p><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><p>在当一个变量用作布尔状态标志时，为了确保及时获得最新的变量值，可以使用volatile关键词，同时由于作为状态判断标志，读的次数是远大于写的，效率上也能够满足要求。</p><h3 id="一次性安全发布（one-time-safe-publication）"><a href="#一次性安全发布（one-time-safe-publication）" class="headerlink" title="一次性安全发布（one-time safe publication）"></a>一次性安全发布（one-time safe publication）</h3><p>在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。本文最上面的示例代码就发生了这种情况。这里就不得不提到著名的双重检查锁定（double-checked-locking）问题了。</p><p>双重检查模式一般是在需要对实例域使用延迟初始化时，为了兼顾性能能考虑使用的一种方式。《Effective Java》这本书中也提到了这个东西，所以我们这里就用书里给的例子来加以说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//延迟初始化的同步方法实现，这是实现起来最简单的一种</span><br><span class="line">//Lazy initialization of instance field - synchronized accessor</span><br><span class="line">private FieldType field;</span><br><span class="line"></span><br><span class="line">synchronized FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        field = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是在性能上，由于每次使用getField()方法都需要加锁，访问这个实例的开销会很大。</p><p>为了优化性能，缩小同步的范围，从对方法的同步缩小到对代码块进行加锁同步。这就是要使用双重检查模式的场景了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private FieldType field;</span><br><span class="line"></span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        cynchronized(this)&#123;</span><br><span class="line">            if(field == null)</span><br><span class="line">                field = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而上面这段代码实际上是不能够有效工作的。不起作用的原因在于编译器对指令进行了重新排序，在这篇文章中不对此内容做更细致的探讨。</p><p>但是为了避免这种情况的出现，在进行第二次检查锁定的同时，增加一个赋值语句来抵消指令重排的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Double-check idiom for lazy initialization of instance fields</span><br><span class="line">private FieldType field;</span><br><span class="line"></span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        FieldType result;</span><br><span class="line">        cynchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是实际上这种方式也是不起作用的，这个就触及到我的知识盲区了，看别人的说法是同步规则的问题，现在的我也不是太懂，先挖个坑，以后有机会在填。</p><p>所以双重检查模式还是使用volatile关键字来解决，因为在jdk5以后，增强了volatile的语义，不允许volatile读操作与其后面的读写操作进行指令重排序。所以使用volatile实现的代码版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        cynchronized(this)&#123;</span><br><span class="line">            if(field == null)</span><br><span class="line">                field = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独立观察-independent-observation"><a href="#独立观察-independent-observation" class="headerlink" title="独立观察(independent observation)"></a>独立观察(independent observation)</h3><p>这种方式模式是定期“公布”观察结果供程序内部使用。例如，如下代码的功能是使用身份验证机制记忆最后一次登录用户的名字，并使用lastUser来引用发布值，供程序其他部分调用，使用volatile的作用可以保证值能够得到及时的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class UserManager &#123;</span><br><span class="line">    public volatile String lastUser;</span><br><span class="line"></span><br><span class="line">    public boolean authenticate(String user, String password) &#123;</span><br><span class="line">        boolean valid = passwordIsValid(user, password);</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            User u = new User();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        return valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="volatile-bean模式"><a href="#volatile-bean模式" class="headerlink" title="volatile bean模式"></a>volatile bean模式</h3><p>就是将JavaBean中的成员变量用volatile修饰，这样做的原因是很多框架为易变数据的持有者（例如HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。</p><h3 id="开销较低的读写锁策略"><a href="#开销较低的读写锁策略" class="headerlink" title="开销较低的读写锁策略"></a>开销较低的读写锁策略</h3><p>当读操作远远多于写操作是，可以结合使用内部所和volatile变量来减少公共代码路径的开销。因为volatile不具有原子性，所以写操作用锁，而读操作只需要保证可见性，于是可以用volatile来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class CheesyCounter &#123;</span><br><span class="line">    // Employs the cheap read-write lock trick</span><br><span class="line">    // All mutative operations MUST be done with the &apos;this&apos; lock held</span><br><span class="line">    @GuardedBy(&quot;this&quot;)</span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123; return value; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized int increment() &#123;</span><br><span class="line">        return value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里部分内容来自<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">正确使用Volatile变量</a>，有兴趣的可以去原博探究一下详细内容。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>volatile作为一种轻量级的同步方式，能够使用的应用场景十分有限，而且在同步的实现上相对比其他方式更容易出现错误，然而在适当的场景做出合理的使用，仍旧是可以达到提高性能的作用。所以，对volatile有足够的了解，找到合适的场景，两者缺一不可。</p>]]></content>
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Java中精确计算的问题</title>
      <link href="/2018/03/20/180320/"/>
      <content type="html"><![CDATA[<blockquote><p>世界上有10种人，一种是懂二进制的，一种是不懂二进制的<br><a id="more"></a></p></blockquote><h2 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h2><p>之前看公司的代码发现有一个提供精确运算的工具类。想起以前确实有听说过浮点数用于计算精确度丢失的问题，但一直是知其然不知其所以然，如今有这个机会，就想着深入的学习一下这方面的相关东西。</p><p>由于计算机对于大小的比较会严格按照值的大小进行。计算时会有误差出现，这种误差会导致进行数值比较时出错。例如计算机不会认为0.9999999等于1。</p><h2 id="找到的答案"><a href="#找到的答案" class="headerlink" title="找到的答案"></a>找到的答案</h2><p>查阅资料发现，原因在于进制的转换问题，在一些情况下十进制数的二进制表示形式可能不够精确。首先，对于十进制的整数，转换成二进制以后是能够除尽的，所以整数能够用二进制精度表示。问题出在小数这里，就像十进制数也有除不尽的数一样，二进制同样存在，而且是一些在十进制下能除尽的数使用二进制无法除尽，在这个进制下是无限小数，超过表示的位数之后就会将之后的部分舍弃，这样就会导致明明精准输入的数在二进制下不够精准，也就出现了精度的丢失。</p><p>这个进制真的也是很神奇的东西，将十进制向二进制转换，整数部分使用“除二取余法”，小数部分使用的是“乘二取整法”，那么要使得确保精度，小数部分的末位就应该是5的倍数。其他时候精度丢失就出现了。</p><p>然而精度的丢失发生在哪一个阶段呢，我们写几行代码看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double g = 0.05;</span><br><span class="line">double h = 0.01;</span><br><span class="line"></span><br><span class="line">System.out.println(h + g);</span><br><span class="line">System.out.println(&quot;test: &quot; + g);</span><br></pre></td></tr></table></figure></p><p>我们可以发现输出的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.060000000000000005</span><br><span class="line">test: 0.05</span><br></pre></td></tr></table></figure></p><p>通过代码来看，精度丢失似乎是发生在运算阶段，然而事实却并非如此。当不进行浮点运算时，可以直接使用定义时给的十进制表示方法，而运算后值发生了精确度上的变化，是因为本身参与运算的值就已经不够精确，在进行运算后，产生了不可预知的结果。</p><p><strong>根据以上得出的结论就是：计算机中的浮点数都是以二进制进行的运算，对于部分由十进制转化为二进制的数由于在进制转化时无法除尽，对相应的二进制数只是一个近似值。所以当使用这种浮点数计算后，将其转换回十进制就会出现很小的误差。这种误差和原始数据是差了很多个数量级的，对数值大小的影响小，但是会影响数值比较时做出的判断。</strong></p><p>所以其实浮点数只适合用于科学计算而不适用于精确计算。在《effective java》 中，也提到了这个原则。（回去找一找看一看再写这个部分）  ： float和剁手了类型主要是为了科学计算和工程计算而设计的，它们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算，不应该被用于需要精确结果的场合</p><h2 id="Java中的解决方案"><a href="#Java中的解决方案" class="headerlink" title="Java中的解决方案"></a>Java中的解决方案</h2><p>那么在java中如何进行精确的小数运算呢，bigdecimal。</p><p>使用BigDecimal并且一定要用String来构造。举个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 提供精确的加法运算。</span><br><span class="line">* @param v1 被加数</span><br><span class="line">* @param v2 加数</span><br><span class="line">* @return 两个参数的和</span><br><span class="line">*/  </span><br><span class="line">//双精度或者浮点类型要转换成String类型再计算  </span><br><span class="line">public static BigDecimal add(double v1, double v2) &#123;  </span><br><span class="line">BigDecimal b1 = new BigDecimal(Double.toString(v1));  </span><br><span class="line">BigDecimal b2 = new BigDecimal(Double.toString(v2));  </span><br><span class="line">return b1.add(b2);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public static BigDecimal add(String v1, String v2) &#123;  </span><br><span class="line">BigDecimal b1 = new BigDecimal(v1);  </span><br><span class="line">BigDecimal b2 = new BigDecimal(v2);  </span><br><span class="line">return b1.add(b2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用BigDecimal还有一些额外的好处，比如可以完全按照自己的想法控制舍入，BigDecimal本身提供了几种舍入模式，选择一种使用十分方便。此外在数字大小超过18位时，也必须使用BigDecimal</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdecimal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Springboot：Spring Data Jpa的使用</title>
      <link href="/2018/03/13/180313/"/>
      <content type="html"><![CDATA[<p>使用spring data jpa 开发时，发现国内对spring boot jpa全面介绍的文章比较少案例也比较零碎，因此写文章总结一下。<br><a id="more"></a></p><h2 id="spring-data-jpa-介绍"><a href="#spring-data-jpa-介绍" class="headerlink" title="spring data jpa 介绍"></a>spring data jpa 介绍</h2><hr><h3 id="首先了解JPA是什么"><a href="#首先了解JPA是什么" class="headerlink" title="首先了解JPA是什么"></a>首先了解JPA是什么</h3><p>JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。他的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，JPA受到了极大的支持和赞扬，其中就包括了Spring与EJB3.0的开发团队。</p><blockquote><p>注意:JPA是一套规范，不是一套产品，那么像Hibernate,TopLink,JDO他们是一套产品，如果说这些产品实现了这个JPA规范，那么我们就可以叫他们为JPA的实现产品。</p></blockquote><h3 id="spring-data-jpa"><a href="#spring-data-jpa" class="headerlink" title="spring data jpa"></a>spring data jpa</h3><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</p><blockquote><p>spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现</p></blockquote><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><hr><p>基本查询也分为两种，一种是spring data默认已经实现，一种是根据查询的方法来自动解析成SQL。</p><h3 id="预先生成方法"><a href="#预先生成方法" class="headerlink" title="预先生成方法"></a>预先生成方法</h3><p>spring data jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等</p><ol><li><p>继承JpaRepository</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用默认方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testBaseQuery() throws Exception &#123;</span><br><span class="line">User user=new User();</span><br><span class="line">userRepository.findAll();</span><br><span class="line">userRepository.findOne(1l);</span><br><span class="line">userRepository.save(user);</span><br><span class="line">userRepository.delete(user);</span><br><span class="line">userRepository.count();</span><br><span class="line">userRepository.exists(1l);</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>就不解释了根据方法名就能看出意思来</p><h3 id="自定义简单查询"><a href="#自定义简单查询" class="headerlink" title="自定义简单查询"></a>自定义简单查询</h3><p>自定义的简单查询就是根据方法名来自动生成SQL，主要的语法是<code>findXXBy</code>,<code>readAXXBy</code>,<code>queryXXBy</code>,<code>countXXBy</code>, <code>getXXBy</code>后面跟属性名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUserName(String userName);</span><br></pre></td></tr></table></figure></p><p>也使用一些加一些关键字<code>And</code>、 <code>Or</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUserNameOrEmail(String username, String email);</span><br></pre></td></tr></table></figure></p><p>修改、删除、统计也是类似语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long deleteById(Long id);</span><br><span class="line"></span><br><span class="line">Long countByUserName(String userName)</span><br></pre></td></tr></table></figure></p><p>基本上SQL体系中的关键词都可以使用，例如：<code>LIKE</code>、 <code>IgnoreCase</code>、 <code>OrderBy</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; findByEmailLike(String email);</span><br><span class="line"></span><br><span class="line">User findByUserNameIgnoreCase(String userName);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findByUserNameOrderByEmailDesc(String email);</span><br></pre></td></tr></table></figure></p><p><strong>具体的关键字，使用方法和生产成SQL如下表所示</strong></p><table><thead><tr><th>Keyword</th><th>Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td>And</td><td>findByLastnameAndFirstname</td><td>… where x.lastname = ?1 and x.firstname = ?2</td></tr><tr><td>Or</td><td>findByLastnameOrFirstname</td><td>… where x.lastname = ?1 or x.firstname = ?2</td></tr><tr><td>Is,Equals</td><td>findByFirstnameIs,findByFirstnameEquals</td><td>… where x.firstname = ?1</td></tr><tr><td>Between</td><td>findByStartDateBetween</td><td>… where x.startDate between ?1 and ?2</td></tr><tr><td>LessThan</td><td>findByAgeLessThan</td><td>… where x.age &lt; ?1</td></tr><tr><td>LessThanEqual</td><td>findByAgeLessThanEqual</td><td>… where x.age ⇐ ?1</td></tr><tr><td>GreaterThan</td><td>findByAgeGreaterThan</td><td>… where x.age &gt; ?1</td></tr><tr><td>GreaterThanEqual</td><td>findByAgeGreaterThanEqual</td><td>… where x.age &gt;= ?1</td></tr><tr><td>After</td><td>findByStartDateAfter</td><td>… where x.startDate &gt; ?1</td></tr><tr><td>Before</td><td>findByStartDateBefore</td><td>… where x.startDate &lt; ?1</td></tr><tr><td>IsNull</td><td>findByAgeIsNull</td><td>… where x.age is null</td></tr><tr><td>IsNotNull,NotNull</td><td>findByAge(Is)NotNull</td><td>… where x.age not null</td></tr><tr><td>Like</td><td>findByFirstnameLike</td><td>… where x.firstname like ?1</td></tr><tr><td>NotLike</td><td>findByFirstnameNotLike</td><td>… where x.firstname not like ?1</td></tr><tr><td>StartingWith</td><td>findByFirstnameStartingWith</td><td>… where x.firstname like ?1 (parameter bound with appended %)</td></tr><tr><td>EndingWith</td><td>findByFirstnameEndingWith</td><td>… where x.firstname like ?1 (parameter bound with prepended %)</td></tr><tr><td>Containing</td><td>findByFirstnameContaining</td><td>… where x.firstname like ?1 (parameter bound wrapped in %)</td></tr><tr><td>OrderBy</td><td>findByAgeOrderByLastnameDesc</td><td>… where x.age = ?1 order by x.lastname desc</td></tr><tr><td>Not</td><td>findByLastnameNot</td><td>… where x.lastname &lt;&gt; ?1</td></tr><tr><td>In</td><td>findByAgeIn(Collection ages)</td><td>… where x.age in ?1</td></tr><tr><td>NotIn</td><td>findByAgeNotIn(Collection age)</td><td>… where x.age not in ?1</td></tr><tr><td>TRUE</td><td>findByActiveTrue()</td><td>… where x.active = true</td></tr><tr><td>FALSE</td><td>findByActiveFalse()</td><td>… where x.active = false</td></tr><tr><td>IgnoreCase</td><td>findByFirstnameIgnoreCase</td><td>… where UPPER(x.firstame) = UPPER(?1)</td></tr></tbody></table><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><hr><p>在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义SQL</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>分页查询在实际使用中非常普遍了，spring data jpa已经帮我们实现了分页的功能，在查询的方法中，需要传入参数<code>Pageable</code> ,当查询中有多个参数的时候<code>Pageable</code>建议做为最后一个参数传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; findALL(Pageable pageable);</span><br><span class="line"></span><br><span class="line">Page&lt;User&gt; findByUserName(String userName,Pageable pageable);</span><br></pre></td></tr></table></figure></p><p><code>Pageable</code>是spring封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPageQuery() throws Exception &#123;</span><br><span class="line">int page=1,size=10;</span><br><span class="line">Sort sort = new Sort(Direction.DESC, &quot;id&quot;);</span><br><span class="line">    Pageable pageable = new PageRequest(page, size, sort);</span><br><span class="line">    userRepository.findALL(pageable);</span><br><span class="line">    userRepository.findByUserName(&quot;testName&quot;, pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>限制查询</strong><br>有时候我们只需要查询前N个元素，或者支取前一个实体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ser findFirstByOrderByLastnameAsc();</span><br><span class="line"></span><br><span class="line">User findTopByOrderByAgeDesc();</span><br><span class="line"></span><br><span class="line">Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);</span><br></pre></td></tr></table></figure></p><h3 id="自定义SQL查询"><a href="#自定义SQL查询" class="headerlink" title="自定义SQL查询"></a>自定义SQL查询</h3><p>其实Spring data 觉大部分的SQL都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的SQL来查询，spring data也是完美支持的；在SQL的查询方法上面使用<code>@Query</code>注解，如涉及到删除和修改在需要加上<code>@Modifying</code>.也可以根据需要添加 <code>@Transactional</code> 对事物的支持，查询超时的设置等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Modifying</span><br><span class="line">@Query(&quot;update User u set u.userName = ?1 where u.id = ?2&quot;)</span><br><span class="line">int modifyByIdAndUserId(String  userName, Long id);</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">@Modifying</span><br><span class="line">@Query(&quot;delete from User where id = ?1&quot;)</span><br><span class="line">void deleteByUserId(Long id);</span><br><span class="line"></span><br><span class="line">@Transactional(timeout = 10)</span><br><span class="line">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span><br><span class="line">    User findByEmailAddress(String emailAddress);</span><br></pre></td></tr></table></figure></p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询在spring data jpa中有两种实现方式，第一种是利用hibernate的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。</p><p>首先需要定义一个结果集的接口类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface HotelSummary &#123;</span><br><span class="line"></span><br><span class="line">City getCity();</span><br><span class="line"></span><br><span class="line">String getName();</span><br><span class="line"></span><br><span class="line">Double getAverageRating();</span><br><span class="line"></span><br><span class="line">default Integer getAverageRatingRounded() &#123;</span><br><span class="line">return getAverageRating() == null ? null : (int) Math.round(getAverageRating());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查询的方法返回类型设置为新创建的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select h.city as city, h.name as name, avg(r.rating) as averageRating &quot;</span><br><span class="line">- &quot;from Hotel h left outer join h.reviews r where h.city = ?1 group by h&quot;)</span><br><span class="line">Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable);</span><br><span class="line"></span><br><span class="line">@Query(&quot;select h.name as name, avg(r.rating) as averageRating &quot;</span><br><span class="line">- &quot;from Hotel h left outer join h.reviews r  group by h&quot;)</span><br><span class="line">Page&lt;HotelSummary&gt; findByCity(Pageable pageable);</span><br></pre></td></tr></table></figure></p><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, &quot;name&quot;));</span><br><span class="line">for(HotelSummary summay:hotels)&#123;</span><br><span class="line">System.out.println(&quot;Name&quot; +summay.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在运行中Spring会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用getXX的形式来获取</p></blockquote><h2 id="多数据源的支持"><a href="#多数据源的支持" class="headerlink" title="##多数据源的支持"></a>##多数据源的支持</h2><h3 id="同源数据库的多元支持"><a href="#同源数据库的多元支持" class="headerlink" title="同源数据库的多元支持"></a>同源数据库的多元支持</h3><p>日常项目中因为使用的分布式开发模式，不同的服务有不同的数据源，常常需要在一个项目中使用多个数据源，因此需要配置sping data jpa对多数据源的使用，一般分一下为三步：</p><ul><li>1 配置多数据源</li><li>2 不同源的实体类放入不同包路径</li><li>3 声明不同的包路径下使用不同的数据源、事务支持</li></ul><p>这里有一篇文章写的很清楚：<a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">Spring Boot多数据源配置与使用</a></p><h3 id="异构数据库多源支持"><a href="#异构数据库多源支持" class="headerlink" title="异构数据库多源支持"></a>异构数据库多源支持</h3><p>比如我们的项目中，即需要对mysql的支持，也需要对mongodb的查询等。</p><p>实体类声明<code>@Entity</code> 关系型数据库支持类型、声明<code>@Document</code> 为mongodb支持类型，不同的数据源使用不同的实体就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Document</span><br><span class="line">public class User &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，如果User用户既使用mysql也使用mongodb呢，也可以做混合使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Document</span><br><span class="line">public class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以通过对不同的包路径进行声明，比如A包路径下使用mysql,B包路径下使用mongoDB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaRepositories(basePackages = &quot;com.neo.repositories.jpa&quot;)</span><br><span class="line">@EnableMongoRepositories(basePackages = &quot;com.neo.repositories.mongo&quot;)</span><br><span class="line">interface Configuration &#123; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr><p><strong>使用枚举</strong></p><p>使用枚举的时候，我们希望数据库中存储的是枚举对应的String类型，而不是枚举的索引值，需要在属性上面添加    <code>@Enumerated(EnumType.STRING)</code>注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Enumerated(EnumType.STRING)</span><br><span class="line">@Column(nullable = true)</span><br><span class="line">private UserType type;</span><br></pre></td></tr></table></figure></p><p><strong>不需要和数据库映射的属性</strong></p><p>正常情况下我们在实体类上加入注解<code>@Entity</code>，就会让实体类和表相关连如果其中某个属性我们不需要和数据库来关联只是在展示的时候做计算，只需要加上<code>@Transient</code>属性既可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Transient</span><br><span class="line">private String  userName;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank" rel="noopener">Spring Data JPA - Reference Documentation</a></p><p><a href="https://www.gitbook.com/book/ityouknow/spring-data-jpa-reference-documentation/details" target="_blank" rel="noopener">Spring Data JPA——参考文档 中文版</a></p><hr><p>作者：纯洁的微笑<br>出处：<a href="http://www.ityouknow.com/springboot/2016/08/20/springboot(%E4%BA%94" target="_blank" rel="noopener">http://www.ityouknow.com/</a>-spring-data-jpa%E7%9A%84%E4%BD%BF%E7%94%A8.html)<br>版权所有，欢迎保留原文链接进行转载：)</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带重复元素以及不带重复元素的全排列</title>
      <link href="/2018/03/09/180309/"/>
      <content type="html"><![CDATA[<blockquote><p>被一块石头绊倒两次是真的丢人——不写引子不舒服斯基<br><a id="more"></a></p></blockquote><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>递归的思想中有几个很重要的特性，对于使用递归求解的问题，把握好这几个因素就能把代码写好了。</p><ol><li>终止条件。递归的方法有一个最终的终止条件，这个条件满足题目所提出的要求，而且不会无限的循环下去。</li><li>子问题。问题中的子问题可以再次递归调用方法求解。这就是分治思想的运用了。在没有满足返回条件之前，每一步和前一步都只是在状态上有不同。</li></ol><h2 id="不带重复元素的"><a href="#不带重复元素的" class="headerlink" title="不带重复元素的"></a>不带重复元素的</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字列表，返回其所有可能的排列。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>你可以假设没有重复数字。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>给出一个列表[1,2,3]，其全排列为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>不带重复元素这个题是很早之前做的了。思路也大概就是写一个递归方法，在方法中判断是否已经全排列，是的话集合加一并返回，不是的话就循环。</p><p>很简单的递归全排列思路，甚至可以直接点地记下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Permute &#123;</span><br><span class="line">public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums)&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">per(res,list,nums);</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void per(List res,List list,int[] nums)&#123;</span><br><span class="line"></span><br><span class="line">if(list.size() == nums.length)&#123;</span><br><span class="line">res.add(new ArrayList(list));</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i = 0;i &lt; nums.length; i++)&#123;</span><br><span class="line">if(list.contains(nums[i]))</span><br><span class="line">continue;</span><br><span class="line">list.add(nums[i]);</span><br><span class="line">per(res,list,nums);</span><br><span class="line">list.remove(list.size()-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带重复元素的"><a href="#带重复元素的" class="headerlink" title="带重复元素的"></a>带重复元素的</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给出一个具有重复数字的列表，找出列表所有不同的排列。</p><p>给出列表 [1,2,2]，不同的排列有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,1,2],</span><br><span class="line">  [2,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>和上面的解法基本上一样，只是要多加一个visited数组来记录这个数据在这一次逐渐深入的递归中是否被使用过，递归返回时改回未被使用。因为允许列表元素重复，所以进行一次普通的全排列后，可能会出现两个相同的排列，为了避免出现重复的排列，所以要进行一次contains的判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class PermuteUnique &#123;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums)&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">int[] visited = new int[nums.length];</span><br><span class="line">permute(0,nums.length,ret,temp,nums,visited);</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用来做递归的子方法，可以当模版参考</span><br><span class="line"> *</span><br><span class="line"> * @param k 当前长度</span><br><span class="line"> * @param n 每个的长度，nums.length</span><br><span class="line"> * @param ret 返回的那个list</span><br><span class="line"> * @param temp 每一次递归用的list</span><br><span class="line"> * @param nums 初始数组</span><br><span class="line"> * @param visited 元素是否被访问过</span><br><span class="line"> */</span><br><span class="line">public void permute(int k,int n,List ret,List temp,int[] nums,int[] visited)&#123;</span><br><span class="line">if(k == n &amp;&amp; !ret.contains(temp))&#123;</span><br><span class="line">ret.add(new ArrayList(temp));</span><br><span class="line">&#125;</span><br><span class="line">if(k &gt; n)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(int i = 0;i &lt; n;i++)&#123;</span><br><span class="line">int pre = nums[i];</span><br><span class="line">if(visited[i] == 0)&#123;</span><br><span class="line">temp.add(pre);</span><br><span class="line">visited[i] = 1;</span><br><span class="line">permute(k + 1,n,ret,temp,nums,visited);</span><br><span class="line">visited[i] = 0;</span><br><span class="line">temp.remove(temp.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一份代码中还有一些地方是可以优化的，比如那个参数n就是完全多于的东西，按照上一份代码其实这个参数是可以不用的，包括k也是，明明就是一个list.size的事，但是当时写代码的时候本着跑起来再说的想法，没有考虑这些问题，虽然之后发现了，但是本着提醒自己的想法，就把没改的版本贴到了这个博客中。</p><h3 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h3><p>这个，偷个懒，以后再说。</p><h2 id="指针问题"><a href="#指针问题" class="headerlink" title="指针问题"></a>指针问题</h2><p>说到指针，按理说学了这么几年已经不应该再在这种事上糊涂了，但是还是犯了错，做之前全排列的那个题时愣是没想通，好在今天做这个题的时候反应过来了，所以借此机会记录一下。</p><p>上面的递归代码中，当排序好的List要放入总的集合中时，之前的我是这样操作的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(k == n &amp;&amp; !ret.contains(temp))&#123;</span><br><span class="line">    //stupid</span><br><span class="line">    ret.add(temp);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><p>用这种add，执行后你会发现结果会大错特错。而应该换用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(k == n &amp;&amp; !ret.contains(temp))&#123;</span><br><span class="line">ret.add(new ArrayList(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对，没错。</p><p>使用上面那个错误操作所存进集合中的并不是一个对象，而是指向这个List对象的指针。这就引起了问题：add进集合中的永远是同一个元素，而且，在带重复元素这道题中，需要进行一次是否已经contains的判断，这个会一直为true，让你甚至连重复元素都加不进去。写代码验证一下这个想法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">temp.add(5);</span><br><span class="line">ret.add(temp);</span><br><span class="line">System.out.println(ret.contains(temp));</span><br><span class="line">temp.add(7);</span><br><span class="line">System.out.println(ret.contains(temp));</span><br><span class="line">ret.add(temp);</span><br><span class="line"></span><br><span class="line">Iterator it = ret.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">[5, 7]</span><br><span class="line">[5, 7]</span><br></pre></td></tr></table></figure></p><p>证明确实如此。所以每次进行add操作时，要new一个新的对象用来存放已经排好序的部分。</p><h2 id="整体感想"><a href="#整体感想" class="headerlink" title="整体感想"></a>整体感想</h2><p>多看，多写，多总结。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>丑数2(Ugly Number Ⅱ)</title>
      <link href="/2018/03/06/180306/"/>
      <content type="html"><![CDATA[<blockquote><p>“今者臣来，见人于大行，方北面而持其驾，告臣曰：’吾欲之楚。’臣曰：‘君之楚，将奚为北面？’曰：‘吾马良。’臣曰：‘马虽良，此非楚之路也。’曰：‘吾用多。’臣曰：‘用虽多，此非楚之路也。’曰：‘吾御者善。’此数者愈善，而离楚愈远耳。”   ——《战国策·魏策四》<br><a id="more"></a></p></blockquote><h2 id="题目：丑数Ⅱ"><a href="#题目：丑数Ⅱ" class="headerlink" title="题目：丑数Ⅱ"></a>题目：丑数Ⅱ</h2><p>设计一个算法，找出只含素因子2，3，5的第n小的数。</p><p>符合条件的数如：1，2，3，5，6，8，9，10，12，15…</p><p>由于观察可以发现，每一个丑数都和之前的一个丑数有关系，因为只含有这几个因子，那么下一个丑数一定是由之前的丑数乘以他的因子得到的。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>因为就只想到了这么多的规律，所以，最初拿到这个题的时候，就以这个规律为解题的思路：对于之前存在的每一个满足条件的数乘以因子数得到之后的数。</p><p>所以最初的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int nthUglyNumber(int n)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;();</span><br><span class="line">al.add(1);</span><br><span class="line">int i = 0;</span><br><span class="line">while(al.size() &lt; n * 2)&#123;</span><br><span class="line">int n2,n3,n4,n5;</span><br><span class="line">n2 = al.get(i) * 2;</span><br><span class="line">n3 = al.get(i) * 3;</span><br><span class="line">n4 = al.get(i) * 4;</span><br><span class="line">n5 = al.get(i) * 5;</span><br><span class="line"></span><br><span class="line">if(!al.contains(n2))&#123;</span><br><span class="line">al.add(n2);</span><br><span class="line">&#125;</span><br><span class="line">if(!al.contains(n3))&#123;</span><br><span class="line">al.add(n3);</span><br><span class="line">&#125;</span><br><span class="line">if(!al.contains(n4))&#123;</span><br><span class="line">    al.add(n4);</span><br><span class="line">&#125;</span><br><span class="line">if(!al.contains(n5))&#123;</span><br><span class="line">al.add(n5);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(al);</span><br><span class="line">Iterator&lt;Integer&gt; it = al.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">return al.get(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种解法看似合情合理，合乎丑数的定义规律，但是仍存在着一定的问题，其实做题时我也发现了，但是以为是能够克服的小问题，最初不太在意导致程序运行出现了问题。</p><ol><li><p>求出的不是最小的丑数。这种方法虽然能够保证求出的都是丑数，但是无法保证这些数出现的顺序，不只是排列顺序的问题，较小的丑数可能会被排在后面的丑数求出。举个例子，由12求得的数为24，36，60，而由15求出的数为30，45，75，16求出的为32，48，80。由这几个数可以看出30，45，32，48都是小于由12求得的60的，而32也是小于45的。这还是数字比较小的时候就出现的顺序错乱，当数字变得很大，数字量很多的时候这种情况会变得更加严重，即使对已经求出的数字进行了排序的操作，也无法判断当前所需要的位置是否是正确的数。这样也就出现了第二个问题。</p></li><li><p>空间和时间的消耗过大。由上一个问题可以发现，如果使用这种方式进行计算，那么为了保证在所求位置的数是满足条件的，它的前面没有出现数据的缺失，那么他的计算量会增大好几倍，而随着数据量的增加，计算的开销也会变得很大。合适能够确定已经达到了所需条件也是一个问题。</p></li></ol><p>在上面的那份代码中可以看到是进行过优化的，比如加入4这个因子，来减小因子差距过大带来的差距，包括把所求的数据扩大到2n也是为了在n处能够是满足条件的那个丑数，但是在数据量很大的时候还是出现了问题，我推断数据量进一步增大问题会更加严峻。而且如果继续扩大这个倍数，例如扩大到3n，那么在数据足够大时，int的长度就会不够用了，再用long的话感觉有点过分。（都是测试时出现的血和泪得来的经验啊T_T）</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>说了那么多关于怎么做错的事情，接下来讲一讲正确的解法。这个解法也是利用丑数性质定义做的，只是思路有点不同：因为每个丑数都是由之前的一个丑数乘以因子得到的，那么下一个丑数就应该是之前的某个丑数乘以因子的最小值。</p><p>这其实感觉是用了动态规划的思想，当前位置的丑数求解看作是一个求之前某些数乘以因子后最小值的状态，每一次求得之后，状态发生了改变但是求解方法并没有发生变化。而且这样只需要求n个数就能够解决问题，是很不错的方法。</p><p>根据这种思路我写了一份代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int nthUglyNumber(int n)&#123;</span><br><span class="line">int[] nums = new int[n];</span><br><span class="line">nums[0] = 1;</span><br><span class="line">int n2 = 0;</span><br><span class="line">int n3 = 0;</span><br><span class="line">int n5 = 0;</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt; n;i++)&#123;</span><br><span class="line">int next = min(nums[n2] * 2,nums[n3] * 3,nums[n5] * 5);</span><br><span class="line">if(next == nums[n2] * 2)&#123;</span><br><span class="line">n2++;</span><br><span class="line">&#125;</span><br><span class="line">if(next == nums[n3] * 3)&#123;</span><br><span class="line">n3++;</span><br><span class="line">&#125;</span><br><span class="line">if(next == nums[n5] * 5)&#123;</span><br><span class="line">n5++;</span><br><span class="line">&#125;</span><br><span class="line">nums[i] = next;</span><br><span class="line">&#125;</span><br><span class="line">return nums[n - 1];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//求最小值</span><br><span class="line">public int min(int i,int j,int k)&#123;</span><br><span class="line">if(i &lt; j)&#123;</span><br><span class="line">return i &lt; k ? i : k;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return j &lt; k ? j : k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一步一步求出来的值就是符合条件的丑数值。</p><h2 id="使用遍历"><a href="#使用遍历" class="headerlink" title="使用遍历"></a>使用遍历</h2><p>其实看网上的博客我发现还有另一种解法，就是进行遍历，对从1开始的每个数挨个查看，检查是否为满足条件的数，检查的方式也是根据丑数的特点：只含有因子2，3，5。如果满足这个条件就认定为是丑数，把计数器加一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean IsUgly(int number)&#123;</span><br><span class="line">    while (number % 2 == 0)&#123;</span><br><span class="line">        number /= 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (number % 3 == 0)&#123;</span><br><span class="line">        number /= 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (number % 5 == 0)&#123;</span><br><span class="line">        number /= 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return number == 1 ? true : false;</span><br></pre></td></tr></table></figure></p><p>这种解法虽然是能够求出结果的，但是在计算量上比我自己的那种解法还大，因为要对所有的数进行是否为丑数的判断，无用的计算量太大，当数字逐渐增大时，在时间上是明显不能够满足题目要求的。</p><h2 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h2><p>素因子可以不为2，3，5，可以换做其他的数，求解的方法也是一样。</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>做题时还是要带上脑子的，特别是一些需要使用所求数据的规律性质的时候要多转一个弯，就像这个题上一样，对于同一个性质，理解方式和侧重点的不同都会使解题的思路不同，结果导致所写出的解法千差万别。找准切入点，找到合适的解法很重要。不然你做的一切不过是南辕北辙。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle官方文档 —— The try-with-resources Statement</title>
      <link href="/2018/02/11/180211/"/>
      <content type="html"><![CDATA[<h2 id="The-try-with-resources-Statement"><a href="#The-try-with-resources-Statement" class="headerlink" title="The try-with-resources Statement"></a>The try-with-resources Statement</h2><p>The try-with-resources statement is a try statement that declares one or more resources. A resource is as an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements <code>java.lang.AutoCloseable</code>, which includes all objects which implement <code>java.io.Closeable</code>, can be used as a resource.<br><a id="more"></a><br>try-with-resources语句是一个声明一个或多个resources的try语句。Resource是指在程序使用结束后必须被关闭的对象。try-with-resources语句保证每个resource都会在语句结束时被关闭。任何实现了<code>java.lang.AutoCloseable</code>和<code>java.io.Closeable</code>接口的对象都可以视作resource。</p><p>The following example reads the first line from a file. It uses an instance of <code>BufferedReader</code> to read data from the file. <code>BufferedReader</code> is a resource that must be closed after the program is finished with it:</p><p>下面这个程序的例子会读取文件的第一行，它使用了<code>BufferedReader</code>的实例来从文件中读取数据。<code>BufferedReader</code>是一个程序使用完以后必须关闭的resource。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static String readFirstLineFromFile(String path) throws IOException &#123;</span><br><span class="line">  try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;</span><br><span class="line">    return br.readLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In this example, the resource declared in the try-with-resources statement is a <code>BufferedReader</code>. The declaration statement appears within parentheses immediately after the try keyword. The class <code>BufferedReader</code>, in Java SE 7 and later, implements the interface <code>java.lang.AutoCloseable</code>. Because the BufferedReader instance is declared in a try-with-resource statement, it will be closed regardless of whether the try statement completes normally or abruptly (as a result of the method <code>BufferedReader.readLine</code> throwing an IOException).</p><p>在这个例子中，<code>BufferedReader</code>作为resource在try-with-resources语句中被声明，声明语句放在紧跟在try这个关键字后的小括号中。BufferedReader这个类，在Java SE 7以及更后面的版本中实现了<code>java.lang.AutoCloseable</code>这个接口。如果BufferedReader实例在一个try-with-resource的语句中被声明，那么不管try语句是否成功执行这个resource都会被关闭（执行<code>BufferedReader.readLine</code>这个方法的结果是抛出IOExcepetion异常）。</p><p>Prior to Java SE 7, you can use a finally block to ensure that a resource is closed regardless of whether the try statement completes normally or abruptly. The following example uses a finally block instead of a try-with-resources statement:</p><p>在Java SE 7之前的版本里，你可以使用finally块来确保resource在任何情况下都能被关闭，下面的这个例子就是使用finally块代替<code>try-with-resources</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException &#123;</span><br><span class="line">  BufferedReader br = new BufferedReader(new FileReader(path));</span><br><span class="line">  try &#123;</span><br><span class="line">    return br.readLine();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (br != null) br.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, in this example, if the methods readLine and close both throw exceptions, then the method <code>readFirstLineFromFileWithFinallyBlock</code> throws the exception thrown from the finally block; the exception thrown from the try block is suppressed. In contrast, in the example readFirstLineFromFile, if exceptions are thrown from both the try block and the try-with-resources statement, then the method <code>readFirstLineFromFile</code> throws the exception thrown from the try block; the exception thrown from the try-with-resources block is suppressed. In Java SE 7 and later, you can retrieve suppressed exceptions; see the section Suppressed Exceptions for more information.</p><p>然而，在这个例子中，如果方法readLine和close都抛出错误，这时方法readFirstLineFromFileWithFinallyBlock 会抛出finally块中抛出的异常；而来自try语句块中的异常会被抑制。相比之下，在例子readFirstLineFromFile中，如果同时从try语句块和try-with-resources语句中抛出错误，那么这个方法实际会抛出try块中的异常；来自try-with-resources块中的异常会被抑制。在Java SE 7以及之后的版本中，你可以得到被抑制的异常；在Suppressed Exceptions这章节中你可以了解更多。</p><p>You may declare one or more resources in a try-with-resources statement. The following example retrieves the names of the files packaged in the zip file zipFileName and creates a text file that contains the names of these files:</p><p>你可能会在一个try-with-resources语句中声明多个resouces。下面的这个例子会从打包的zip文件zipFileName中获得这些文件的文件名，同时创建一个文本文件来储存这些文件名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void writeToFileZipFileContents(String zipFileName, String outputFileName)</span><br><span class="line">  throws java.io.IOException &#123;</span><br><span class="line"></span><br><span class="line">  java.nio.charset.Charset charset = java.nio.charset.Charset.forName(&quot;US-ASCII&quot;);</span><br><span class="line">  java.nio.file.Path outputFilePath = java.nio.file.Paths.get(outputFileName);</span><br><span class="line"></span><br><span class="line">  // Open zip file and create output file with try-with-resources statement</span><br><span class="line"></span><br><span class="line">  try (</span><br><span class="line">    java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);</span><br><span class="line">    java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)</span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    // Enumerate each entry</span><br><span class="line"></span><br><span class="line">    for (java.util.Enumeration entries = zf.entries(); entries.hasMoreElements();) &#123;</span><br><span class="line"></span><br><span class="line">      // Get the entry name and write it to the output file</span><br><span class="line"></span><br><span class="line">      String newLine = System.getProperty(&quot;line.separator&quot;);</span><br><span class="line">      String zipEntryName = ((java.util.zip.ZipEntry)entries.nextElement()).getName() + newLine;</span><br><span class="line">      writer.write(zipEntryName, 0, zipEntryName.length());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In this example, the try-with-resources statement contains two declarations that are separated by a semicolon: <code>ZipFile</code> and <code>BufferedWriter</code>. When the block of code that directly follows it terminates, either normally or because of an exception, the close methods of the BufferedWriter and ZipFile objects are automatically called in this order. Note that the close methods of resources are called in the opposite order of their creation.</p><p>在这个例子中，try-with-resources语句包含了两个用分号隔开的声明语句：<code>ZipFile</code>和<code>BufferedWriter</code>。当紧跟着这个语句的代码块结束时，不管是正常结束还是因为发生异常，BufferedWriter和ZipFile的close方法都会被自动地按顺序调用。注意这些resources的close方法的调用顺序和它们的创建语句顺序相反。</p><p>The following example uses a try-with-resources statement to automatically close a <code>java.sql.Statement</code> object:</p><p>下面的这个例子使用try-with-resouces语句自动关闭一个<code>java.sql.Statement</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void viewTable(Connection con) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    String query = &quot;select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES&quot;;</span><br><span class="line"></span><br><span class="line">    try (Statement stmt = con.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">      ResultSet rs = stmt.executeQuery(query);</span><br><span class="line"></span><br><span class="line">      while (rs.next()) &#123;</span><br><span class="line">        String coffeeName = rs.getString(&quot;COF_NAME&quot;);</span><br><span class="line">        int supplierID = rs.getInt(&quot;SUP_ID&quot;);</span><br><span class="line">        float price = rs.getFloat(&quot;PRICE&quot;);</span><br><span class="line">        int sales = rs.getInt(&quot;SALES&quot;);</span><br><span class="line">        int total = rs.getInt(&quot;TOTAL&quot;);</span><br><span class="line">        System.out.println(coffeeName + &quot;, &quot; + supplierID + &quot;, &quot; + price +</span><br><span class="line">                           &quot;, &quot; + sales + &quot;, &quot; + total);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The resource <code>java.sql.Statement</code> used in this example is part of the JDBC 4.1 and later API.</p><p>这个例子中的java.sql.Statement使用的是JDBC4.1及之后版本的API。</p><p><strong>Note</strong>: A <code>try-with-resources</code> statement can have catch and finally blocks just like an ordinary try statement. In a try-with-resources statement, any catch or finally block is run after the resources declared have been closed.</p><p><strong>注意</strong>：一个<code>try-with-resources</code>语句中也可以像单个try语句一样拥有catch和finally语句块。在一个try-with-resources语句中，任何catch或者finally语句块将在resources打开的资源被关闭后执行。</p><h2 id="Suppressed-Exceptions"><a href="#Suppressed-Exceptions" class="headerlink" title="Suppressed Exceptions"></a>Suppressed Exceptions</h2><p>An exception can be thrown from the block of code associated with the try-with-resources statement. In the example <code>writeToFileZipFileContents</code>, an exception can be thrown from the try block, and up to two exceptions can be thrown from the try-with-resources statement when it tries to close the <code>ZipFile</code> and <code>BufferedWriter</code> objects. If an exception is thrown from the try block and one or more exceptions are thrown from the try-with-resources statement, then those exceptions thrown from the try-with-resources statement are suppressed, and the exception thrown by the block is the one that is thrown by the <code>writeToFileZipFileContents</code> method. You can retrieve these suppressed exceptions by calling the <code>Throwable.getSuppressed</code> method from the exception thrown by the try block.</p><p>与try-with-resources有联系的代码块能抛出异常。在例子<code>writeToFileZipFileContents</code>中，try后的语句块中可能抛出异常，而且当试图关闭<code>ZipFile</code>和<code>BufferedWriter</code>对象时，try-with-resouces语句中可能抛出多达两个异常。如果有一个来自try语句块的异常和多个来自try-with-resources语句的异常，那么来自try-with-resources语句中的异常抛出会被抑制，块中的那个异常会被这个方法抛出。你可以通过调用<code>Throwable.getSuppressed</code>方法来获得那些被try块抑制的异常。</p><h2 id="Classes-That-Implement-the-AutoCloseable-or-Closeable-Interface"><a href="#Classes-That-Implement-the-AutoCloseable-or-Closeable-Interface" class="headerlink" title="Classes That Implement the AutoCloseable or Closeable Interface"></a>Classes That Implement the AutoCloseable or Closeable Interface</h2><p>See the Javadoc of the <code>AutoCloseable</code> and <code>Closeable</code> interfaces for a list of classes that implement either of these interfaces. The Closeable interface extends the AutoCloseable interface. The close method of the Closeable interface throws exceptions of type IOException while the close method of the AutoCloseable interface throws exceptions of type Exception. Consequently, subclasses of the AutoCloseable interface can override this behavior of the close method to throw specialized exceptions, such as IOException, or no exception at all.</p><p>查看Javadoc可以找到实现了<code>AutoCloseable</code>和<code>Closeable</code>之一的接口的类列表。Closeable接口继承自AutoCloseable接口。Closeable接口中的close方法抛出的是IOException类型的异常，而AutoCloseable接口中抛出的是Exception类型的异常。因此，实现AutoCloseable接口的类可以重写这个close方法让它更加具体，例如IOException或者不抛出异常。</p><p>PS：英文水平有限，只能做到把文章的意思用中文复述了一遍。也没有加一些自己的理解。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态内部类</title>
      <link href="/2018/02/08/180208/"/>
      <content type="html"><![CDATA[<blockquote><p> 越学习，越觉无知                                        ——鲁迅《没说过》<br><a id="more"></a></p></blockquote><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>昨晚在寝室翻书的时候，看到《Effective Java》中有提到，当遇到多个构造器参数很多，而且存在许多可选域的情况下，即使是使用重叠构造器也会十分麻烦，而如果使用JavaBean的setter方式，又不能满足一些类中的值初始化后不能修改的性质要求。</p><p>书里提到了一种使用Builder构建器的方式，使用静态内部类来简化多可选参数的初始化过程。对部分内容进行简化后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BuilderTest &#123;</span><br><span class="line">private final int var1;</span><br><span class="line">private final int var2;</span><br><span class="line"></span><br><span class="line">private BuilderTest(Builder builder)&#123;</span><br><span class="line">this.var1 = builder.var1;</span><br><span class="line">this.var2 = builder.var2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class Builder&#123;</span><br><span class="line">//必须项</span><br><span class="line">private final int var1;</span><br><span class="line">//可选项</span><br><span class="line">private int var2 = 0;</span><br><span class="line"></span><br><span class="line">public Builder(int var1)&#123;</span><br><span class="line">this.var1 = var1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Builder setVar2(int var2)&#123;</span><br><span class="line">this.var2 = var2;</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BuilderTest build()&#123;</span><br><span class="line">return new BuilderTest(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这其实就是设计模式中提到的Builder模式，将一个类的构建过程从这个类中剥离出来，虽然这个例子里是用的静态内部类实现，但是完全可以新建一个外部类来完成构建的工作。甚至可以将构建器定义为接口来使用。</p><p>使用了构建器模式创建对象的实例就可以通过方法链的方式进行属性值的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BuilderTest bt = new BuilderTest.Builder(5).setVar2(3).build();</span><br><span class="line">System.out.println(&quot;var1: &quot; + bt.var1);</span><br><span class="line">System.out.println(&quot;var2: &quot; + bt.var2);</span><br></pre></td></tr></table></figure><p>输出的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1: 5</span><br><span class="line">var2: 3</span><br></pre></td></tr></table></figure></p><p>上面的那个方法链写出来以后是不是觉得有点眼熟？没错，JDK8对集合进行增强操作的Stream API，就应该是使用了这种设计模式，当然内部的数据处理的实现比起上面这个例子是要复杂很多的。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>当学到这里的时候，我产生了一些疑惑。虽然现在解决以后觉得当时的自己很蠢，但是还是想把这些想法记录下来。</p><p>疑惑的点在于静态内部类的static关键字。之前知道使用static关键字修饰变量、代码块、方法的一些用途，就是当这些东西被static关键字修饰以后都会脱离实例对象成为类变量或类方法。</p><p>而如果一个类被声明为static的会发生什么，这一点并不清楚，因为类只有是内部类的这一种情况下才允许使用static进行修饰。那么这个static类和其他的static修饰的东西在使用上有什么不同？为什么还是要和其他类一样实例化，既然同样也需要实例化那么它和非静态内部类的区别在哪？它的生命周期有范围在哪？</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>带着这些疑问我去看了很多资料和博客，不过很多博客只是提到了静态内部类和非静态内部类的区别，并没有提到更多的东西。而这两者的区别就在于和外部类是否有联系，非静态内部类实例化后会有一个指向外部类的指针。而静态内部类实例化时不会产生指向外部类的指针，单独对它的外部类进行实例化时静态内部类也不会被实例化，两者之间虽然一个是外部类一个是内部类但是感觉上好像毫无联系。</p><p>正是因为不依赖于外部类这个特性，就可以避免无法及时被GC回收而导致的内存泄漏的问题。</p><p>从虚拟机的角度来看，被static修饰的内容会被装载到方法区的静态区，对于普通的静态区中的内容，它可以在类没有实例化时就能够被指针指向，也就表现出属于类而不属于实例的特性。根据这个特点我认为静态类也是这样的一种特性，虽然内部类是静态的，但是里面的变量和方法并不是静态的，同样需要被实例化以后将对象放在堆中才能使用，而static这个关键字是为了在外部类不被实例化时就能够被指针引用，从而实例化这个内部类而不用经过外部类。（不知道自己这个理解对不对）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样一看的话，其实静态内部类就很好理解了，它就是一个嵌套在类内部的顶层类，和普通的类一样，不过因为定义在其他类的内部所以需要使用static修饰使其对虚拟机可见，在实例化时不用依赖于外部类的实例对象。使用场景有限，通常是为了方便分包而使用。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>静态内部类内静态变量的访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BuilderTest &#123;</span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    //在静态内部类中声明一个静态变量</span><br><span class="line">    public static class Builder&#123;</span><br><span class="line">    public static int TEST = 22;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//两种方式都能访问到TEST这个变量</span><br><span class="line">System.out.println(&quot;BuilderTest.Builder.TEST:&quot; + BuilderTest.Builder.TEST);</span><br><span class="line">System.out.println(&quot;Builder.TEST:&quot; + Builder.TEST);</span><br></pre></td></tr></table></figure></p><p>以及静态内部类的其他不同叫法：</p><p>《Effective Java》里称其为静态成员类(static member class)，书里提到当不需要指向其外部类的实例，就应该使用静态成员类。</p><p>oracle官方文档里称作Static Nested Classes（静态嵌套类），文档写到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, to create an object for the static nested class, use this syntax:</span><br><span class="line"></span><br><span class="line">OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态内部类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lambda表达式和函数式接口</title>
      <link href="/2018/01/29/180129/"/>
      <content type="html"><![CDATA[<blockquote><p>刚进公司时，公司正处于由JDK7换用JDK8的时间短，之所以更换JDK版本，听说是公司业务中需要用到JDK8的一些新特性。鉴于我现在也无事可做，姑且来学习总结一下JDK8的一些特性吧。水平有限，这篇勉强算是对他人博客上零散内容的一个总结。<br><a id="more"></a></p></blockquote><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><p>Lambda表达式 匿名函数，当需要一个函数而又不想给他一个命名时，在java中，对于那些只使用一次的方法使用这种方式，能够减少命名上的负担。</p><p>允许将行为传入函数，取代匿名类。很经典的就是一个实现Runnable接口的例子，之前很长一段时间用的是匿名内部类，现在有了lambda表达式来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用匿名内部类</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;The old runable now is using!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">//使用lambda表达式</span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;It&apos;s a lambda function!&quot;)).start();</span><br></pre></td></tr></table></figure><p>减少了很多代码量，也使得代码结构更加清晰。</p><p>允许使用函数式风格编程，将函数当成参数传递给某个方法，或者把代码本身当作数据处理</p><p>结构写法上，lambda表达式由三部分组成： (参数列表)，符号 -&gt; ，函数体（多个语句时加上{}）。可以访问类的成员变量和局部变量，但是会转为final。</p><p>具体的一些匿名函数的使用，由于不太能用到所以不过多说明，仅举部分例子来作为使用时写法的参考，以集合类的遍历为例，虽然用之前的写法也不复杂。之所以选择集合类就是因为很熟悉，不用写原先的遍历方法出来，也能很好的对比两种写法的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//List的遍历</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">list.forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">//Map的遍历</span><br><span class="line">LinkedHashMap&lt;Integer,Integer&gt; lhm = new LinkedHashMap&lt;&gt;();</span><br><span class="line">lhm.put(1, 4);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">lhm.forEach((k,v) -&gt; System.out.println(&quot;key:&quot; + k + &quot; value:&quot; + v));</span><br></pre></td></tr></table></figure><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><p>函数式接口是SAM（Single Abstract Method ）类型的接口，是为了让现有功能能和Lambda表达式能够良好兼容所想出的方法。</p><p>定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个lambda表达式作为参数。换个角度说就是，当我们调用一个方法，可以传入lambda表达式作为参数，那么这个方法的参数类型，必定是一个函数式的接口。</p><p>就是指<strong>只有一个函数</strong>的接口，这样的接口可以被隐式转换为Lambda表达式。例如，<code>java.lang.Runnable</code> 和 <code>java.util.concurrent.Callable</code>等。</p><p>但是函数接口代码层面十分脆弱，只要这个接口中有其他的函数就会编译失败，为了解决函数接口在实际使用过程中的脆弱性。采用显式说明的方式，jdk8提供了一个<code>@FunctionalInterface</code>这个注解来进行声明。</p><p>不过默认方法和静态方法不会破环函数式接口的定义。</p><p>举上面提到的两个jdk中代码的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个都是函数式接口的写法，然后我们来对比一下使用lambda和不使用lambda表达式的写法差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//不使用Lambda表达式时</span><br><span class="line">Runnable runnable1=new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;RunningwithoutLambda&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//使用Lambda表达式的写法</span><br><span class="line">Runnable runnable2=()-&gt;&#123;</span><br><span class="line">    System.out.println(&quot;RunningfromLambda&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><p>其他什么predicate，stream之类的以后有机会有时间再来补充讨论。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习AOP时的一个问题</title>
      <link href="/2018/01/25/180125/"/>
      <content type="html"><![CDATA[<blockquote><p>这几天在公司看项目代码，翻到了aop的部分，本着学习的想法看了下使用AspectJ实现对日志的管理。但是在看这段代码的时候有一个问题一直困扰着我，就是代码的执行顺序。<br><a id="more"></a></p></blockquote><h2 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h2><p><code>@Around</code>这个注解的作用之类的就不在这里介绍了，只说其中的一个问题，使用<code>ProceedingJoinPoint</code>类获得切入点之后，用<code>proceed()</code>方法执行被切部分的代码。</p><p>问题就在这里，公司的代码中这个Advice方法具有一个Object的返回值，是proceed()方法调用后的返回值，那么如果在被切的类中，调用了被切方法的返回值，因为赋值操作和切面操作都是在方法之后执行，那么谁会更先执行呢？</p><p>在验证之前先说个推论吧。如果赋值语句先执行那么aop方法中的返回值将毫无意义，那么方法就可以改为void的返回值类型。如果around是在编译时将目标方法包裹住，是对目标方法的一种编译时内容扩充，那么对于aop方法，就应该记录proceed方法的返回值并返回。由于around增强具有修改参数这个功能，我比较倾向于第二种，能够获得返回值甚至进行修改的看法。</p><blockquote><p>说到底，能有这种困扰还是因为当初没有好好学习aop的内容，加上没有实际项目和具体问题来深入研究。现在书也还了，图书馆也关门了，只能依靠互联网了。</p></blockquote><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h4 id="advice-通知"><a href="#advice-通知" class="headerlink" title="advice 通知"></a>advice 通知</h4><p>通知感觉可以看作是切面需要完成的工作，这里面就包括了之前有所了解的五种通知类型。其他四种，before，after，after-returning，after-throwing都不会关心你的返回值。</p><h4 id="pointcut-切点"><a href="#pointcut-切点" class="headerlink" title="pointcut 切点"></a>pointcut 切点</h4><p>切点定义的是执行通知的连接点，因为一个通知可能不需要通知所有的连接点，相当于定位操作。</p><h4 id="join-point-连接点"><a href="#join-point-连接点" class="headerlink" title="join point 连接点"></a>join point 连接点</h4><p>连接点通俗一点的说法就是能够执行通知的时间点。</p><blockquote><p>其他术语不介绍了，慢慢看</p></blockquote><p>根据介绍，确实是通过包裹住目标方法的方式，实现织入。那么就可以开始写代码证明了。</p><hr><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>首先找一个返回值不为void的方法，这里我用的是自己之前一个项目中查找用户实体的service。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer find(String id);</span><br></pre></td></tr></table></figure></p><p>这个方法返回的是自己定义的一个Customer类型的对象，创建一个aop的切面来包围这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* com.px.service.*Service.find(..))&quot;)</span><br><span class="line">private void aspectjMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Around(value = &quot;aspectjMethod()&quot;)</span><br><span class="line">public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable&#123;</span><br><span class="line">    logger.info(&quot;before method&quot;);</span><br><span class="line">    Object returnValue = pjp.proceed();</span><br><span class="line">    logger.info(&quot;after method&quot;);</span><br><span class="line">    logger.info(&quot;returnClass: ---&gt;&quot; + returnValue.getClass().toString());</span><br><span class="line">    Customer customer = (Customer) returnValue;</span><br><span class="line">    logger.info(customer.toString());</span><br><span class="line">    customer.setName(&quot;Armourr&quot;);</span><br><span class="line">    return customer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中实现对目标方法的包围，执行目标方法后调用返回值<code>returnValue.getClass().toString()</code>得到返回对象的具体类名，然后将这个对象强制转换成Customer类型，打印相关信息并修改这个对象的部分信息，将修改后的对象作为返回值返回。</p><p>之后编写测试用例，执行service中的方法，打印返回值的相关内容信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void aopTest()&#123;</span><br><span class="line">    String id = &quot;1026&quot;;</span><br><span class="line">    Customer customer = customerService.find(id);</span><br><span class="line">    logger.info(&quot;return value: -----&gt;&quot; + customer.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终控制台输出的log信息为如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] before method</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO] after method</span><br><span class="line">[INFO] returnClass: ---&gt;class com.px.entity.Customer</span><br><span class="line">[INFO] Customer&#123;id=&apos;1026&apos;, name=&apos;customer25&apos;, gender=&apos;female&apos;, phone=&apos;134856225&apos;, email=&apos;customer25@163.com&apos;, description=&apos;hello world!&apos;&#125;</span><br><span class="line">[INFO] return value: -----&gt;Customer&#123;id=&apos;1026&apos;, name=&apos;Armourr&apos;, gender=&apos;female&apos;, phone=&apos;134856225&apos;, email=&apos;customer25@163.com&apos;, description=&apos;hello world!&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>通过观察日志信息不难发现，find方法执行后获得的返回值是已经被aop方法修改过的。因此，可以得出程序执行到切点时，会按照aop中的代码执行相关的aop操作，之后才会返回程序原来的部分继续执行。</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedHashMap学习笔记</title>
      <link href="/2018/01/23/180123/"/>
      <content type="html"><![CDATA[<blockquote><p>前几天看到一篇关于面试问题的博客，里面提到LinkedHashMap和TreeMap区别于HashMap的地方有一点就是是否有序，当时不甚明白，因为觉得LinkedHashMap用的是链表结构的，不知道是如何实现有序的，所以去看了看源码和一些文章。<br><a id="more"></a></p></blockquote><hr><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>LinkedHashMap继承自HashMap，内部类Entry也是继承自HashMap.Node&lt;K,V&gt;，但是里面定义了两个独有的元素：<code>Entry&lt;K,V&gt; before, after;</code>，有序就是通过这两个元素来实现。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>LinkedHashMap实现的基本思想就是对<code>多态</code>的使用。它许多方法都是使用的HashMap中已有的方法，通过对方法中调用的子方法进行复写，通过动态绑定，实现方法重用。</p><h5 id="1-内部属性"><a href="#1-内部属性" class="headerlink" title="1.内部属性"></a>1.内部属性</h5><p>在我所看的1.8版本的jdk中，定义了一个静态节点元素Entry，以及这个链表的头元素head和尾元素tail，这两个元素是用来方便对链表进行操作的。</p><p>此外还有一个特有的属性<code>final boolean accessOrder</code>，这是一个用来确定LinkedHashMap的顺序的值，若初始化时确定为false代表按照插入顺序，true表示按照最后操作顺序。在调用构造方法进行初始化时，如果没有指定这个值，默认都是为false。而且构造方法都是调用父类的构造方法来实现的。</p><h5 id="2-有序实现"><a href="#2-有序实现" class="headerlink" title="2.有序实现"></a>2.有序实现</h5><p>我们在此先不讨论accessOrder为true的情况，单说按照插入顺序访问的实现方式。</p><p>刚才有提到Entry节点比父类中的多了两个指针，before和after，看到这两个指针时大概就能想到实现按照插入顺序的访问应该是在插入节点时记录他的before和after两个值。知道了它的大概方式，我们来找它的具体实现。</p><p>观察源码可以发现LinkedHashMap中关于元素存取，值重写了get方法，并没有重写put方法。之所以会重写get方法是因为要实现按照元素最后访问顺序的有序方式。我们来到父类HashMap中,当桶中相应位置没有元素时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure></p><p>当hash值对应位置有元素存在时，且新元素的key不跟其他元素相同时，在链表末尾将新元素加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line">if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">else &#123;</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, null);</span><br><span class="line">            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            break;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察代码发现新节点的加入使用的是newNode方法，这个方法在子类中是重写了的，所以会调用子类中的newNode方法，所以我们又回到了LinkedHashMap中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法会new一个Entry，通过linkNodeLast将其顺序确定下来，然后返回一个Entry类型的元素。所以其实有序的实现是放在了linkNodeLast这个方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用之前定义的tail来操作，新建一个last元素保存tail的引用，将传入的元素设置为最后一个，然后确定两个元素之间的指向问题。这样就将插入的顺序记录了下来。</p><p>另外，accessOrder=true的情况也是对这个指针的指向的修改，通过将最后访问的节点改到tail的位置，本文不作深入的探讨。</p><h5 id="3-迭代器遍历"><a href="#3-迭代器遍历" class="headerlink" title="3.迭代器遍历"></a>3.迭代器遍历</h5><p>LinkedHashMap内部定义了一个内部抽象类，LinkedHashIterator，里面定义了相关的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历时使用after来改变指向，就能够按照顺序来访问了。它的子类有LinkedKeyIterator，LinkedValueIterator，LinkedEntryIterator三个，都实现了Iterator接口，使用时能够自动根据数据类型动态绑定相应的方法进行遍历的实现。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedHashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>淮中晚泊犊头</title>
      <link href="/2018/01/01/title/"/>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="淮中晚泊犊头"><a href="#淮中晚泊犊头" class="headerlink" title="淮中晚泊犊头"></a>淮中晚泊犊头</h2><p><br></p><p>苏舜钦</p><p>春阴垂野草青青，时有幽花一树明。</p><p>晚泊孤舟古祠下，满川风雨看潮生。</p>]]></content>
      
      <categories>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
