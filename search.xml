<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Git使用总结</title>
      <link href="/2019/03/03/190303/"/>
      <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行<br><a id="more"></a></p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>来到新的公司，第一件事当然是配环境这个毋庸置疑。小组内开发新项目，需要多人合作共同完成，第一件就是找一个好用的版本控制软件。版本控制软件就不在这里介绍了，Git、SVN其实都是有学过和用过的。但是问题依旧存在，那就是之前不管是跟同学组队开发项目或者是在github使用Git，还是在之前那个公司实习的时候用SVN，都只是轻度的使用，而且操作及其不规范，只是做到了提交代码，并没有做到很好的进行版本控制。</p><p>因此，在刚来这里的时候，就在提交代码的问题上出现了很大的问题，就是对于规范的流程和操作不熟悉，同时也因为不是自己一个人的项目，不敢放开手脚尝试各种命令的实际效果，只能去询问别人如何解决，所以出现问题不仅处理效率极低，而且也很麻烦别人，结果不好。</p><p>好在最困难的日子都已经过去，坑也踩了个七七八八，因为以前有过明明知道这个问题以前遇到过却死活想不起来以前是怎么解决的经历，加上也零零散散地记了不少笔记。就想着抽时间出来把各处的记录整合一下，一来是知识能够系统一点，二来是方便未来忘了解决方案的自己。</p><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h3><h4 id="Git相比于SVN的优势"><a href="#Git相比于SVN的优势" class="headerlink" title="Git相比于SVN的优势"></a>Git相比于SVN的优势</h4><ol><li>分布式<br>SVN是程序集中存放在服务器中，开发下载代码到自己电脑上。git是将完整的版本库存放在各个用户的电脑上，去中心化。</li></ol><p>好处就是查看版本记录不受网络的影响，不会因为svn服务器影响自己业务的开发或者回滚进度。</p><ol><li>存储方式<br>svn等这些存储数据，主要是通过文件变更列表的方式来存储信息，将保存的信息看做是一组基本文件和每个文件随时间逐步累积的差异。Git采用的是把数据看作是对小型文件系统的一组快照。对保存项目时的全部文件制作一个快照，并保存快照索引。</li></ol><p>git有一个元数据，就是.git文件夹里的信息。关于与版本控制有关的信息都在这里面集中存放。</p><p>别人的文章里提到svn是每个文件都有一个<code>.svn</code>文件，管理起来麻烦，并且目录文件忽略的时候设置起来相当麻烦，这个有体会，而在git里只需要维护一个<code>.gitignore</code>的文件就行了，方便不少。在<code>.gitignore</code>文件里只要列出要忽略的文件模式，可以过滤掉不需要跟踪的文件</p><h4 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h4><p>之前说过git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p><p>在进行提交操作时，git会保存一个提交对象（commit object），该提交对象会包含一个指向暂存内容快照的指针，同时还有一些提交信息和指向父对象的指针。</p><p>git仓库中的对象分为三类，一个是提交对象，包含指向前述树对象的指针和提交信息；一种是树对象，记录着目录结构和blob对象索引；blob对象，一般有多个，保存着文件快照</p><p>（所以其实git的管理就是创建了一个提交信息的链表）</p><p>所以git其实只是管理的提交对象以及其内部存储的文件信息和提交信息，所谓不同的分支其实就是指向不同提交对象节点的一些指针而已。</p><p>HEAD指向当前所在的分支，相当于一个分支的别名。指向会在<code>checkout</code>时修改。</p><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><ol><li><p>master<br>远端的master分支是每个使用者最熟悉的，</p></li><li><p>develop<br>这个分支作为主要的开发分支，被称作集成分支。平行于master分支，当develop这个分支达到稳定，并且准备好发版的时候，就合并到master分支上去，并标注好发布的版本号。</p></li><li><p>feature<br>这个分支应该是从develop这个分支分出来的，这个是开发新功能所开的分支。当开发一个新功能时，这个功能的目标版本可能是未知的。feature这个分支的精髓在于会和这个功能的开发周期一样长，但最终会合并到develop里或者是被丢弃。这个一般只在开发者的repo里存在，不会放进origin里</p></li></ol><h4 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h4><ol><li><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">git branch -r #查看远程分支</span><br><span class="line">git branch -a #查看所有分支</span><br><span class="line">git branch    #查看本地分支，后面带有参数的话可以创建本地分支</span><br><span class="line">git branch -vv #这个是查看本地分支与远程分支的映射关系</span><br><span class="line"></span><br><span class="line">git checkout  #带有参数的话可以切换到那个分支</span><br><span class="line">git checkout -b dev origin/develop #新建一个本地分支dev，与远程分支develop建立映射关系，并切换工作分支到这个分支。</span><br><span class="line">Switched to a new branch &apos;dev&apos; # Branch &apos;dev&apos; set up to track remote branch &apos;develop&apos; from &apos;origin&apos;.（执行后控制台的输出）</span><br><span class="line"></span><br><span class="line">git pull #拉取当前分支代码</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git commit -amend #撤销操作</span><br><span class="line"></span><br><span class="line">git add *  # 多功能命令 跟踪新文件/把已跟踪文件放到暂存区/合并时将有冲突的文件标记位已解决状态</span><br><span class="line"># 对于这个命令的含义应该理解为“添加内容到下一次提交中”</span><br><span class="line"></span><br><span class="line"># 如果修改了一个已被跟踪的文件，使用status会出现changes not staged for commit</span><br><span class="line"># 这说明跟踪的文件已经发生了变化，但是没有放进暂存区</span><br><span class="line"></span><br><span class="line"># 查看哪些文件处于什么状态</span><br><span class="line"># 主要是显示上次提交过后的修改，以及当前分支与对应远程分支之前的偏离</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git diff # 查看尚未暂存的文件更新了那些部分</span><br><span class="line"></span><br><span class="line">git diff --cached</span><br><span class="line">git diff --staged # 这两个命令都是查看已暂存的将要添加到下次提交里的内容，后者需要高一些的版本而已</span><br><span class="line"></span><br><span class="line">git commit    # 这种提交方式会启动文本编辑器输入本次提交的说明</span><br><span class="line">git commit -m # 会将提交命令放在同一行</span><br><span class="line">git commit -a # 直接把所有已经跟踪过的文件暂存起了一并提交</span><br><span class="line"></span><br><span class="line">git rm # 从已跟踪文件清单（暂存区域）和工作目录中删除指定的文件</span><br><span class="line"></span><br><span class="line"># 如果只是从工作目录中收工删除文件，会在git status时出现 changes mot staged for commit</span><br><span class="line"></span><br><span class="line">git rm -f # -f = force 删除之前如果放到暂存区的话应使用这个，防止误删没有添加到快照的数据</span><br><span class="line"></span><br><span class="line">git log # 查看提交历史（这个用命令行太麻烦了，不需要）</span><br><span class="line"></span><br><span class="line">git reset # 用来取消暂存</span><br><span class="line"></span><br><span class="line">git push (origin) (branch) # 将自己的项目推送到远端分支</span><br><span class="line"></span><br><span class="line">untracked 未跟踪，意思是git在之前的提交中没有这些文件，git不会自动将文件纳入跟踪范围，这样可以保证自动生成的二进制文件或者缓存文件包含进来（比如python会自动生成的__pycache__文件）</span><br></pre></td></tr></table></figure></li><li><p>feature分支的创建与合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## 合并可以先考虑合并到本地dev，再把本地dev推到远端</span><br><span class="line"></span><br><span class="line"># creating a feature branch</span><br><span class="line">git checkout -b myfeature develop</span><br><span class="line"># Switched to a new branch &quot;myfeature&quot;</span><br><span class="line"></span><br><span class="line"># merge</span><br><span class="line">git checkout develop</span><br><span class="line"># Swritched to branch &apos;develop&apos;</span><br><span class="line"></span><br><span class="line">git merge --no-ff myfeature</span><br><span class="line">git branch -d myfeature</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></li><li><p>release分支从develop分支的创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-1.2 develop</span><br><span class="line"># Switched to a new branch &apos;release-1.2&apos;</span><br><span class="line"></span><br><span class="line">./bump-version.sh 1.2</span><br><span class="line"># Files modified successfully,version bumped 1.2.</span><br><span class="line"></span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2&quot;</span><br><span class="line"># [release-1.2 ...] Bumped version number to 1.2</span><br><span class="line"># 1 files changed, 1 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></li></ol><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p><code>git push --set-upstream origin feature-htmlReport</code>推本地分支到远端（在远端没有这个分支的情况下使用）</p><p><code>git push (remote) (branch)</code></p><ol><li>已经commit的会在push的时候全部带上，说白了一个是提交一个是推到远端</li><li><code>git push origin ...</code>和<code>git pull origin...</code>分别是拉到本地和推到远端，推到远端没有用过，但是推之前很明显应该先拉到本地检查冲突，避免把别人提交的代码覆盖了，而pull之前又需要stash本地的代码，那就是要用到commit了</li></ol><p><code>untracked files</code>问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">git status # 用这个命令查看当前的git状态，根据这个状态来寻找解决办法，很好用</span><br><span class="line"></span><br><span class="line"># 问题是会在控制台显示changes not staged for commit，以及untracked files</span><br><span class="line"># 首先删除跟踪</span><br><span class="line"></span><br><span class="line"> git rm logs/\*.git</span><br><span class="line"></span><br><span class="line"># 发现error，因为the following files have local modifications</span><br><span class="line">(use --cached to keep the file, or -f to force removal)</span><br><span class="line"></span><br><span class="line"> git rm -f logs/\*.log</span><br><span class="line"></span><br><span class="line"># 之后再尝试pull</span><br><span class="line"></span><br><span class="line"> git pull origin develop</span><br><span class="line"></span><br><span class="line"># 依旧出现error，The following untracked working tree files would be overwritten by merge: .... Please move or remove them before you merge.</span><br><span class="line"># 在StackOverflow上找到的解决办法</span><br><span class="line"></span><br><span class="line"> git add ....（相关文件）</span><br><span class="line"> git stash</span><br><span class="line"> git pull</span><br><span class="line"></span><br><span class="line">(之后就是解决冲突了)</span><br><span class="line"></span><br><span class="line"> git push</span><br><span class="line"></span><br><span class="line">(结束)</span><br></pre></td></tr></table></figure></p><p>出现问题的原因，本地的<code>.gitignore</code>和其他分支上的不同，导致pull到我本地的时候出现。<br>由于本地没有追踪这个文件，但是远程追踪了，所以pull会强制覆盖本地没有进入版本控制下的文件。</p><p><code>git fetch</code> 从服务器上抓取本地没有的数据时，不会修改工作目录，而是让你自己合并。<br><code>git pull</code> 相当于<code>git fetch</code> 加上<code>git merge</code>，所以有时候会出现问题。</p><p>删除远程分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> git push origin :feature</span><br><span class="line">(git push [远程名] [本地分支]:[远程分支])</span><br><span class="line"></span><br><span class="line"># 使用这个命令，在省略本地分支的情况下，意思是用空白代替远程分支，就是删除的意思</span><br></pre></td></tr></table></figure></p><p>其他的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &apos;develop&apos; of git.mail.netease.com:datapi/dpmonitor into develop</span><br></pre></td></tr></table></figure></p><p>这种情况是出现了冲突解决冲突后的提交会有的一行merge说明。<br>实现过程，先把本地的修改commit，之后pull远程，之后解决冲突。这时有可能会发生明明解决了冲突但是还是说你存在的问题，这时使用git add，之后再commit就行了</p><p>通过查看git的官方文档发现，在合并时会遇到需要使用三个快照的情况，即你的分支和想要合并的分支都做了修改，这时git会把三方进行一个合并，并将这次合并的结果做了一个提交。就是上述的这种情况。使用ide进行冲突解决的话你会发现有三个窗口，而这种合并提交会有不止一个父提交。</p><p>其实实际操作过程中跟上述描述内容也不全相同，因为实际上并没有在本地新建分支，直接在映射到远程develop分支的本地分支上干活，不过也差不多，毕竟不管你本地取的名字是不是叫develop，对于git来说你仍然是一个branch。</p><p>在ide里使用git的时候也会遇到一些问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canot mommit changes due to unresolved conflicts.</span><br><span class="line"></span><br><span class="line">出现这个问题的原因，在于使用了命令行参数git pull拉下来的代码里有冲突，手动把冲突部分删除了以后，再使用ide的commit，他不认。</span><br><span class="line"></span><br><span class="line">这时可以尝试继续使用命令行的git push来推到远端。当然这个不够稳妥，以我的性格当然不会这么做，那么就可以再用ide的pull按钮拉一次，再合并一次代码，万无一失。</span><br><span class="line">commit</span><br><span class="line">这时默认的提交信息也就变成了</span><br><span class="line">Merge branch &apos;develop&apos; of git.mail.netease.com:datapi/dpmonitor into develop</span><br><span class="line"></span><br><span class="line">nice</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望自己能够尽快彻底地熟悉git命令，做到不需要使用ide提供的功能。（当然有些好用的功能，比如快速解决冲突以及修改高亮这些是不可能不用的，工具毕竟还是为了效率而生的）</p><p>特别说一下<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a>，这个中文版文档是真的很好用了，虽然对于你遇到的某个问题可能在stackoverflow上解决的更快，但是只要你耐心地读完完整的文档，你自然会知道该怎么去做。</p><p>其实我也还没有完整的看过一遍，只是阅读了前三章关于git基础和操作的部分。感兴趣、有时间的话，自然是全部读完更好，但是仅作为一个工具，目前已经足够，因为还有太多的东西等着去学，精力不足，对于很多东西没有办法太过深入，只能浅尝辄止，留待将来。</p>]]></content>
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在春节假期结束</title>
      <link href="/2019/02/10/190210/"/>
      <content type="html"><![CDATA[<blockquote><p>人恒过，然后能改，困于心衡于虑而后作，征于色发于声而后喻。入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也。<br><a id="more"></a></p></blockquote><p>前个月从一堆免费书籍里翻出了流浪地球，在公交车里看完了全文，现在回想起来，和电影讲的是两个完全不同的故事。唯一相同的地方，大概只在“希望是比钻石还要珍贵的东西”，都是在绝望之中挖掘那一丝若有若无的希望。电影里是木星带来的，书里是更广和更深的绝望，有趣的是，不管是书里还是电影里最终还是抓住了希望的种子。科幻，本身就有科学也有幻想，抛开整部电影故事而只去纠结其中的不科学之处有那么一点本末倒置的意味。</p><p>到今天看完这部电影，我的这个春节就算是结束了，这才意识到像这样的假期时间开始不够用了，有好些事都还没安排上，虽然有些事假期再长也白搭，明年复明年。</p><p>想起回来后走在街上，总会感觉这城好小，这距离好近。爬上魁山，一切仿佛就都在眼前了，那天天气也好，最远能看到四面包裹着县城的山岭，有种望尽天涯路的感觉。</p><p>之前坐在火车里，看着窗外，那些城市里的高楼，深山里的瓦房，热闹的集市，迎面驶过的火车里一张张模糊的脸，想着那些楼，那些房子，那些人看着都那么相似，又都独一无二，独自运转，每个人都有不同的人生有不同的故事，这时心里总一种莫名的感觉，但又描述不出来。<br>面对的世界变得广阔，需要处理的东西变得复杂，情绪的交织就会变得更加强烈，什么都有，又什么都不是。太多颜色加在一起总会变成灰色。小时候不懂的一团乱麻，现在才开始理解。有些东西说出来轻飘飘的，到时间了自然会重重的压下来，让你明白。</p><p>天下大势，历史车轮，裹挟着太多人一起前进，温和时如滚滚江河，暴烈时如山洪汹涌。就算不至顺者昌逆者亡，也差不太多。一个人的成长，大致上还是循序渐进，由简入繁地去适应去接受这个世界的安排，再去争渡。只是有时候这个过程也会来得如暴风骤雨，任你跪地求饶也无路可退。</p><p>生于忧患，而死于安乐。</p><p>战战兢兢，如临深渊，如履薄冰。</p><p>未来的起点是今天，昨日已是镜中花，明天还只是水中月。</p><p>有疑惑大概是学识不够去理解，没办法准确表达出来恰也佐证了这一点。不过牢骚得发，写不好也得写，就像日记，为了未来的我能够在淹没的时间里翻阅到今天的自己。</p><p>以己为镜，可知何事？</p><p>—— 2019年2月10日 正月初六 凌晨1点27分 于中江家中</p>]]></content>
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋招总结</title>
      <link href="/2018/10/11/181011/"/>
      <content type="html"><![CDATA[<blockquote><p>一分耕耘，一分收获<br><a id="more"></a></p></blockquote><h3 id="一段流水账"><a href="#一段流水账" class="headerlink" title="一段流水账"></a>一段流水账</h3><p>九月的最后一天，收到了一个满意的offer，于是就开心起来了。总想着要写点什么才好。正好今天醒的很早，那就在这个清晨，借着台灯的微光，听着窗外的虫鸣，来回顾一下秋招的这几个月的日子吧。（比起寝室，我果然还是更喜欢待在家里）</p><p>先从流水账讲起。账目来自朋友圈、聊天记录或是截图。</p><p>一想到秋招的开始，第一反应就是感谢小蔡。如果不是他着急着赶回宿舍，还天天说着要开始准备秋招了，我可能不会那时就开始行动。说来也挺巧的，企业里的组长回家照顾他刚出生的双胞胎儿子去了，我正好没有了事做。六月中旬，我开始了秋招的复习。</p><p>记得当时我还列了一个大致的复习计划，为了均衡每一个方面，周一虚拟机，周二计算机网络，一直排到了周末都还不够用。也知道自己是基础太差，不能再去系统性的学习一遍了，就从面经开始。为每一个部分开了一个文档，把面经里有关这个部分的问题写在里面，然后去网上找答案。</p><p>那时候虽然自己菜的抠脚，却还没有意识到问题的严重性，还去看了101，去看了omg对阵fpx的比赛。不过这也挺合理的，毕竟只要在学习就已经比以前的自己好的多了，一下子成佛也不太现实。</p><p>那时候还有阳狗算是战友，因为他毕竟是要保研/考研的人，我们两个人的点不一样。（我极度怀疑他更多是因为女朋友跟他提了分手，我们不一样，不一样）</p><p>那二十多天的成都，迎来了一场持续的大规模降雨，每天打着伞出门，打着伞回来，因为雨太大骑不了车，只能步行，看着旁边开过去的汽车，会想着如果我也是坐在里面该有多舒服。不过我可没有驾照，更没钱买车。</p><p>七月，该玩的一样都没有落下，有比赛看比赛，有电影去看电影，听到别人回家了也跟着回家玩去。每天可能只有上午在教室里待着，讲道理这点时间是不够的，但是我还是没有意识到问题的严重性。七月最后的十天，还狠狠地放纵了自己，说什么回来就要好好玩，有空就蹲在麻将馆，每天都在外面吃饭，什么事也不做，什么事也不想做。所以还是要感谢一下每天早上带着我去泡图书馆的人，至少让我有时间看了一部分的剑指offer。</p><p>差点忘了，七月最刺激的应该是那一口瓜了。人心呐。不过还好我本来也不太喜欢这个人，也算不上太熟，就是她们会比较难受一点吧。</p><p>那几天我还回了趟乡下，今年雨季太持久了，多年没人住没人修的老房子垮了。堂屋后面靠山的那一堵墙，塌了一大半，神龛和相片都掉了下来。以前小时候没察觉，那一天突然觉得那间屋子好小，可能我是真的长大了吧。现在脑海里还能清晰的浮现出那时候的那间屋子，那架床，那张桌子，那台电视，光滑的地面，和感觉要走很久的屋子，还有那个要抬腿才能迈过的门槛。低头一看，门槛不过一两层台阶的高度。</p><p>八月，他们各自回学校了，我也收拾东西回去了。听说二教不再开放了，便每天早上爬起来跑去图书馆。说实话，这一个月在图书馆里的时间，比我这大学前三年加起来都要多。但是有一件很难受的事情，就是图书馆在维修，整栋楼都是电钻的声音。而且不止这些，对我来说日子仿佛只有上午，中午饭点回去以后，下午和晚上就成了咸鱼，除了比赛还是比赛。我记得我只有一天在图书馆从上午待到了下午，那一天我可能要吹一辈子了，因为感觉以后也不会再有。</p><p>去了趟德阳，看了爷爷奶奶，我也想天天陪着他们的。</p><p>跟她吃了顿饭，如果把那天和之后的面试对比的话，那可能是最凉的一次。不过也是那一天让自己心里更有b-tree了，算是圆了个梦。goodbye to you。</p><p>这个月的最后就是网易给我的那次面试机会了。那时候接个电话还会紧张到不行，从那天起，我意识到了问题的严重性。（战歌起）</p><p>金九，大家都这么称呼这个月。我改了改那被人用坏了的句子来描述它，这是最好的时间，也是最坏的时间。</p><p>网易的那次失败让我意识到了自己的各种问题，从简历到基础再到项目和面试过程中的回答。直到现在我也不敢拿起那天的录音再听一遍，这种勇气我没有。在之后的几天里，小林子自暴自弃就不谈了，小蔡拿到了网易的转正，干老师收到了阿里飞猪，我珂不慌不忙的面完腾讯等开奖。</p><p>不得不说，有这三个大佬在，是真的压力贼大，不过也是因为有他们才有我知耻而后勇的动力。突然想起了暑假某天跟他们讨论东西到十二点的故事，睡着以后小蔡那句你是对的，算是有了一点成就感，毕竟大多数的时候他们讨论东西我只能在旁边听着。</p><p>之后就是被各种短信狂轰乱炸的日子了。因为实力不济，只能广撒网，笔试题做了不知道多少套。（数了一数，大概三十来套）最多的一天，我收到了七个笔试链接，被虐得死去活来。还有那一些招聘网站，天天发骚扰邮件，打骚扰电话，特别是大街网，让人有点受不了。</p><p>然后就是面试了，前几次电话面试是真的有点菜，紧张，没经验，加上不知道该怎么扩展，基本都是二十多分钟就被面试官问“有什么想问我的”了。这时候就又要感谢一下小蔡了，梳理回答逻辑的思路也是他说的，优化简历也是在他的提醒之下，这两个点算是之后面试经历里很重要的地方了。</p><p>不过那几天的日子真是难过啊。每一天都无比的焦急，好几天都熬到了一两点才睡着，总想着要找人说点什么，但是其实找到他们发现也没有什么好说的，只能自己扛过来。</p><p>真正找回自信的应该是度小满那天的面试了。在清水河，约了十一点，九点过就赶了过去，然后马上就给我安排上了面试。那应该是我的第一次现场面试了。问了很多基础，感觉自己都答了上来，特别是提到了我简历上写的GC，于是我从收集算法给他讲到了垃圾收集器，感觉还是不错的。后来写代码也是，第一题直接就是环链表，不过表现的太明显，他又重新给了个找公共父节点的问题，最后磕磕绊绊写了出来。明明代码没写出来，也不知道自己当时哪来的自信，就很开心，也许是因为面试持续了一个多小时，对我来说是个突破。而就在那一天，我感觉自己的心魔，碎了。</p><p>之后就是贝壳和网易的那一天，算是一个重要的日子。还好贝壳电话来得早，加上和网易离得近，在时间冲突的时候我选了他放弃了4399，不然也不会有今天的我了。那几天正是胃特别难受的日子，一直干呕，也没什么胃口，只是不想身体出现其他问题，还坚持着按时吃饭。还记得那天在贝壳的等候区里，我连旺旺仙贝都吃不下去，只在等面试的过程中太无聊拍了一些照片。</p><p>说来也是运气吧，贝壳大规模招人，去的人却很少。一面的面试官是个做C++的，实在是太明显了，最后我特地问了一下，感觉是这一问让他给了我过。二面是个老大级别的人物，一上来就直接问到怎么减少stw的时间，还好我有准备，然而这应该也是我回答的最好的一个问题了，之后的问题不管是基础知识还是分布式，都一塌糊涂。不过感觉他觉得还行，给我讲了很多思路和公司概况，也是因为这，让我觉得自己能过。和hr小姐姐不说是聊得开心，也算是中规中矩吧，因为也没有什么奇怪的问题。（其实我觉得要我很大程度上是因为我说能去实习）</p><p>从贝壳面完hr出来，已经快一点了，出来就直接往网易那边走过去，那天胃是真的难受，记得我都走到乡村基的门口了，一阵恶心又让我退了回来。但是不能不吃，所以去买了个面包，边走边吃。下过雨的河边小路，满地都是打落的桂花，抬头就是桂枝，感觉伸一伸脖子，鼻尖就能碰到花香。</p><p>刚到网易的时候，去到29楼，上午的面试才刚结束，面试官们拿了饭回去吃。我也很困了，坐在窗口，背靠着29层的天空小憩。不过也没让我等太久，一点半刚过就开始了，一面还是很简单的，都是基础，而且不让你深入解释，算是了解你的一个知识广度，除了分布式不了解以外，感觉自己回答的还是蛮好的。然后回来等了一个小时的二面，大概是因为还有很多上午面完一面在等二面的人。二面深入的讲了讲锁，之后就是生产者消费者问题了，虽然之前看过，也写了出来，但是面试官看起来不太满意，觉得我代码能力不强，虽然事实也是如此。（接下来的几个月要多写写代码了）不过就算如此，他还是让我过了，很开心，以至于到hr面的时候有点忘乎所以了。跟hr说了太多不该说的，而且还乱说了好多话，都是没有经验惹的。整整五十分钟才结束，让回来等消息，这一等就等到了国庆，还音讯全无。</p><p>那天才知道，面试是真的累人，回来以后直接就躺在床上什么也不想做了。不是感觉自己能过才这样，就只是单纯的累。不过确实那天给了我一个良好的反馈，虽然之后对待面试更加从容了，但是也回归了之前的那种不怎么学习的状态。这个国庆假期回去不能再这样了。</p><p>又过了两天，收到了oppo的面试邀约。其实在这之前还有一个猿辅导内推的面试，但是由于是第一次视频面，加上自己没有怎么好好准备，写个代码还写了半个小时，直接就凉透了。oppo那天也没想着能过，就是来看看，凑个热闹。场面也确实挺热闹的，感觉人很多，我都是四百多号了，听后来的介绍是大概共有1500人在成都站，打算招150人，淘汰比例不算太夸张。一面没等太久，但是面试体验很不好，面试官对于redis的使用问得太细节了，自己又没用过，只知道一点理论，所以答得不好。而且这个面试官自己也有毒，一秒钟一个“嗯”真的让人很难受。第二天二面，面试官应该是个什么主管，随便问了问一些东西，也答得不怎么好，毕竟系统架构是真的了解的少，不过好在智力题解了出来。hr面的小姐姐人也很不错，虽然安慰应该只是客套，但是还是让人很舒服。（不像网易）</p><p>结束的时候，告诉我说当天就能出结果，于是我回去休息了一天。（做了答辩ppt）到睡了还没来消息，但是不知怎么的就还是很安心的睡了。不过，心中应该还是有执念的，不然不会半夜三点醒来。醒来第一件事就是拿手机看一看，有条短信，oppo进入签约阶段。那叫一个开心啊。从零到一的突破。那一晚之后就再也没睡着了，虽然没睡着有一半是干老师和小林子的功劳。</p><p>学校里答辩的事情就不提了，跟秋招无关。去oppo签约那天，本来都想好了要怎么跟hr说，说些什么，早早的就到了会场，结果发现是一个签约会，所有人都在一起。于是九点到，看遍了oppo所有广告，十点开始，听了oppo前世今生，父母弟兄，现场填了一个两方和信息表，等我排队弄完已经是快到两点了。真饿。当时听完工资组成，特别是入职步骤以后就不想再待在这个公司了，因为他们毕竟不算是互联网公司，只是有一个写代码的部门。按照他们对于应届生的要求是要统一去组装手机，卖手机和当客服的，我不喜欢，而且对于加班的态度也不清不楚，年薪大头在年终奖，年终奖第一年还没有，还没办法提前去实习。都让我很不满意，但是毕竟手上没有其他offer，所以算是屈服了吧。毕竟先要有工作，才能来谈其他的嘛。</p><p>之后就收拾东西回家了，等到了九月的最后一天，转了无数个超越妹妹，打着撸啊撸就接到了贝壳的offer call。当时看到010开头的电话号码激动得不行，直接挂机去接电话，确认了对方是贝壳hr以后，整个人都要跳起来了，但是嘴上还是很淡定的跟hr交流，以至于让她觉得我有点冷淡，不像是要去她们公司的样子。 也不知道为什么，感觉经常被不熟悉的人这样说，之前去医院针灸，医生也觉得我太淡定了，但是熟悉我的人应该不会这个觉得。哈哈。</p><h3 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h3><p>就在这几天又收到了网易发的offer，然后整个人都不好了。因为两个offer半斤八两的关系，又开始纠结了起来，我曾经以为这种事情不会发生在我身上的。</p><p>不过大佬还是大佬，别人比你付出的多，收获的肯定也会比你更多。室友C昨天收到腾讯offer call，说是小sp，总包能有35w。想想网易今年开的工资，一脸辛酸.jpg。</p><p>不过想太多也没什么用，还是从现在开始好好学习吧，应该也不算晚。</p>]]></content>
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL语句的学习与使用</title>
      <link href="/2018/05/23/180523/"/>
      <content type="html"><![CDATA[<blockquote><p>从实际出发，坚持理论与实践相结合的原则。<br><a id="more"></a></p></blockquote><h3 id="导语篇"><a href="#导语篇" class="headerlink" title="导语篇"></a>导语篇</h3><p>最近由于工作的需要，遇到了需要大量使用sql语句的地方，同时也有一定的难度，至少以学校所学是没法解决的，所以想在这里写下这篇博客，记录一下所学到的所用到的知识，既是总结也是一次重新学习，顺便能利用公司庞大的数据表和查询结构来提高自己，因为单靠自己估计不会有遇到这种复杂的问题的机会。</p><h3 id="语法篇"><a href="#语法篇" class="headerlink" title="语法篇"></a>语法篇</h3><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>根据oracle的官方文档来看，分为普通case表达式和搜索case表达式两种，用个例子说明，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//simple_case_expression</span><br><span class="line">CASE sex</span><br><span class="line">WHEN &apos;1&apos; THEN &apos;男&apos;</span><br><span class="line">WHEN &apos;2&apos; THEN &apos;女&apos;</span><br><span class="line">ELSE &apos;未知&apos; END</span><br><span class="line"></span><br><span class="line">//searched_case_expression</span><br><span class="line">CASE</span><br><span class="line">WHEN sex=&apos;1&apos; THEN &apos;男&apos;</span><br><span class="line">WHEN sex=&apos;2&apos; THEN &apos;女&apos;</span><br><span class="line">ELSE &apos;未知&apos; END</span><br></pre></td></tr></table></figure></p><p>两种方式的区别在于，simple case更加简洁，而searched case功能更多，甚至可以写判断式</p><p>case的作用：</p><ol><li>将已知数据按照另一种方式进行分组，比如给一定范围内的数据划分一个等级</li><li>用一个sql语句完成不同条件的分组</li><li>在check中使用</li></ol><h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><p>根据一定的规则进行分组。通过一定的规则将一个数据集划分成为若干个小的趋于，然后对若干小区域进行数据处理</p><p>使用规则：</p><ol><li>group by X 的意思是所有具有相同X字段值的记录放在同一个分组里</li><li>group by X,Y 意思是将所有具有相同字段值X和Y的记录放在同一个分组，也就是在第一层分组的基础上再进行一次分组</li></ol><p>使用时要注意的点：</p><ol><li>组函数以外的select列表里的字段，必须出现在group by中。</li><li>使用group by进行分组，select列表中的字段必须要有组函数。</li><li>如果要对分组后的结果再进行筛选，要用having而不是where</li></ol><p>这里既然提到了分组函数，那么就做一个简要的介绍。分组函数作用于一组数据，并对一组数据返回一个值，例如avg，max，sum，count这些。也叫聚合函数吧，因为英文名是aggregate function。分组函数一般会和group by一起使用。</p><h4 id="with-…-as"><a href="#with-…-as" class="headerlink" title="with … as"></a>with … as</h4><p>这个语句用来定义一个sql语句片段，这个片段能够被整个sql语句使用，也就是一个子查询。用来取出一个较长的sql片段提高可读性，也可以用在union的数据源部分，避免了语句的冗余以及多次查询。</p><p>注意问题：</p><ol><li>后面必须直接跟使用它的sql语句（如select insert update等），否则将失效。</li><li><p>可以定义多个代码片段，但是只能由一个with，多个片段之间用逗号”,”隔开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with</span><br><span class="line">cte1 as</span><br><span class="line">(</span><br><span class="line">    select ···</span><br><span class="line">),</span><br><span class="line">cte2 as</span><br><span class="line">(</span><br><span class="line">    select ···</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>当命名和数据库表或是视图重名时，后面紧跟的那个语句还是使用这个子查询。</p></li></ol><h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>这个操作符用于合并多个select语句的结果集。union内部的每个结果集应该有数量相同的列，列也应该是拥有相似的数据类型，顺序也要一致。</p><p>union结果集中的列名总是等于union中第一个select语句中的列名。</p><p>union all与union语句都是合并结果集的操作，不过union all不会剔除重复的记录，union在合并结果集后会删除重复的记录，还会进行排序。所以使用union all效率是高于union的。</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>通常来讲，子查询返回的数据的类型有三种，返回一张数据表，返回一列值，返回单个值。返回类型不同在使用时也会有不同。</p><ol><li>作为数据源使用</li></ol><p>当子查询在外部查询FROM字句之后使用时，即使子查询只返回一个单一值(Scalar)或是一列值，依然可以看作是一个特殊的数据源。作为数据源使用的子查询很像视图，但是只是临时存在，不在数据库中。</p><p>使用子查询的返回类型要随外层方法的不同而变化，例如在from关键字后的子查询可以返回一张二维表，而in这种只能返回单列数据，所以其实还是按照外围的方法来的。</p><ol><li>作为选择条件使用</li></ol><p>作为选择条件的子查询是那些值返回一列的子查询，单个值当作只有一行的列使用。</p><p>（有种说法是，尽量不要使用IN，除非IN里面是固定的值，可以使用EXISTS等关键字代替，在<a href="http://wiki.lessthandot.com/index.php/Subquery_typo_with_using_in" target="_blank" rel="noopener">Subquery typo with using in</a>详细的说明和讲解，我在这里就不再赘述）</p><ol><li>子查询作为计算列使用</li></ol><p>当子查询作为计算列使用时，会针对外部查询的每一行，返回单个唯一值。</p><h3 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h3><p>sql作为一种声明式的语言，和其他许多程序语言不同，你不需要告诉计算机应该怎么做，而是要告诉计算机你要什么。</p><p>所以，sql语句在执行顺序上与声明顺序有着很大的不同，而且根据使用的数据库的不同解析方式也会有所变化。</p><p>因为sql语句在执行过程中每个步骤都会产生一个虚拟表，这个虚拟表会作为下一个步骤的输入。所以了解执行顺序对于写出正确的sql语句是十分重要的，例如，在where中不能够使用select中设定的别名，就是因为select是在where之后执行。</p><h4 id="select语句的执行顺序（从使用者角度）"><a href="#select语句的执行顺序（从使用者角度）" class="headerlink" title="select语句的执行顺序（从使用者角度）"></a>select语句的执行顺序（从使用者角度）</h4><ol><li>from子句组装来自不同数据源的数据；</li><li>where子句基于指定的条件对记录行进行筛选；</li><li>group by子句将数据划分为多个分组；</li><li>使用聚集函数进行计算；</li><li>使用having子句筛选分组；</li><li>计算所有的表达式；</li><li>select 的字段；</li><li>使用order by对结果集进行排序。</li></ol><h4 id="select语句的执行步骤（从内部实现角度）"><a href="#select语句的执行步骤（从内部实现角度）" class="headerlink" title="select语句的执行步骤（从内部实现角度）"></a>select语句的执行步骤（从内部实现角度）</h4><ol><li>语法分析，分析语句的语法是否符合规范</li><li>语义分析，检查语句中涉及的数据库对象是否存在，以及用户的权限</li><li>视图转换，将涉及视图的查询语句转换为相应的对基表查询语句</li><li>表达式转换，将复杂的SQL表达式转换为较简单的等效连接表达式</li><li>选择优化器，不同的优化器一般产生不同的执行计划</li><li>选择连接方式，oracle有三种连接方式</li><li>选择连接顺序，确定多表连接时哪个表为源数据表</li><li>选择数据的搜索路径，确定是使用全表搜索还是索引或其他方式</li><li>运行执行计划</li></ol><h4 id="逻辑查询处理阶段"><a href="#逻辑查询处理阶段" class="headerlink" title="逻辑查询处理阶段"></a>逻辑查询处理阶段</h4><p>1、 FROM：对FROM子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表VT1。</p><p>2、 ON：对VT1应用ON筛选器，只有那些使为真才被插入到TV2。</p><p>3、 OUTER (JOIN):如果指定了OUTER JOIN(相对于CROSS JOIN或INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到VT2，生成TV3。如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表位置。</p><p>4、 WHERE：对TV3应用WHERE筛选器，只有使为true的行才插入TV4。</p><p>5、 GROUP BY：按GROUP BY子句中的列列表对TV4中的行进行分组，生成TV5。</p><p>6、 CUTE|ROLLUP：把超组插入VT5，生成VT6。</p><p>7、 HAVING：对VT6应用HAVING筛选器，只有使为true的组插入到VT7。</p><p>8、 SELECT：处理SELECT列表，产生VT8。</p><p>9、 DISTINCT：将重复的行从VT8中删除，产品VT9。</p><p>10、ORDER BY：将VT9中的行按ORDER BY子句中的列列表顺序，生成一个游标(VC10)。</p><p>11、TOP：从VC10的开始处选择指定数量或比例的行，生成表TV11，并返回给调用者。</p><h4 id="工作中的两个实际应用"><a href="#工作中的两个实际应用" class="headerlink" title="工作中的两个实际应用"></a>工作中的两个实际应用</h4><p>在公司的系统中，统计使用的实现方式是查询出所有的内容，将所有的数据都放进一个vo数组中，在服务器端拼接html语句，再传输到前端去。（因为并没有使用视图层的框架，是采取直接传html、js再用ajax获取数据的方式）</p><p>由于上述的实现和显示方式，那么在查询出的结果集中就需要有表头和表项两个部分。</p><ol><li>按照某一字段的种类进行统计</li></ol><p>这个相对简单一些，只需要对选出的数据进行一次分组，再用union加上一个表头行和一个总计行就行了，抛去中间的对一些数据权限字段的验证等，以最高学历的统计为例，这种实现方式的sql语句结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WITH tempStatsData AS(</span><br><span class="line">SELECT (case when p.highestEducationName is null then &apos;未知&apos; else p.highestEductationName end) 项目, count(p.id) 合计</span><br><span class="line">FROM police_base_info p where 1=1</span><br><span class="line">GROUP BY p.highestEducationName</span><br><span class="line">)</span><br><span class="line">SELECT &apos;总计&apos; 项目,SUM(t.合计) 合计,null 百分比 FROM tempStatsData t</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT t.项目,t.合计,ROUND(t.合计*100/SUM(t.合计) over(),2) 百分比 FROM tempStatsData t</span><br><span class="line">ORDER BY 合计 DESC</span><br></pre></td></tr></table></figure></p><ol><li>对某一字段分类统计</li></ol><p>而如果需要对数据进行分段就会比较麻烦了，比如把出生日期转换成年龄段来进行统计，这种需求最容易想到的方式就是把出生日期统一成不同年龄区间的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case when trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=0 and trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&lt;=18 then &apos;0~18岁&apos;</span><br><span class="line">case when ··· then ···</span><br><span class="line">else ··· end</span><br></pre></td></tr></table></figure></p><p>但是这种方式得到的只是一个修改了表项的原始数据表，因为sql语句的执行顺序原因，没有办法进行分组操作。但是我们可以以这张表作为一个中间表，对此表内的数据进行二次操作，达到按照年龄段分组的统计结果。当然在具体执行过程中，年龄段的分配可以动态变化，所以sql语句是可以拼接的，下面给出的语句也只是一个demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">with temp as(select</span><br><span class="line">(case  when trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=0 and trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&lt;=18 then &apos;0~18岁&apos;</span><br><span class="line">when trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=25 and trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&lt;=34 then &apos;25~34岁&apos;</span><br><span class="line">when trunc(months_between(to_date(&apos;2018-04-26&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=35 then &apos;35岁以上&apos; else null end) 项目,</span><br><span class="line">(case when b.sys_permCode = &apos;#&apos; then 1 else 0 end) keshi0,</span><br><span class="line">(case when b.sys_permCode = &apos;#&apos; then 1 else 0 end) keshi1,</span><br><span class="line">(case when b.sys_permCode = &apos;#&apos; then 1 else 0 end) keshi2,</span><br><span class="line">from pp_worker_base_info b where 1=1</span><br><span class="line">and b.sys_permCode in (&apos;#&apos;,&apos;#&apos;,&apos;#&apos;)</span><br><span class="line">)</span><br><span class="line">select tc.项目 ,nvl(keshi0,0) 科室0, nvl(keshi1,0) 科室1, nvl(keshi2,0) 科室2, 合计,nvl(百分比,0) 百分比</span><br><span class="line">from (select tt.项目 项目,sum(t.keshi0) keshi0,sum(t.keshi1) keshi1,sum(t.keshi2) keshi2,count(t.项目) 合计,</span><br><span class="line">decode(count(t.项目),0,0,round(count(t.项目) * 100 / sum(count(t.项目)) over(),2)) 百分比</span><br><span class="line">from temp t</span><br><span class="line">right join(</span><br><span class="line">select &apos;0~18岁&apos; 项目, 1 sort from dual</span><br><span class="line">union</span><br><span class="line">select &apos;25~34岁&apos; 项目, 2 sort from dual</span><br><span class="line">union</span><br><span class="line">select &apos;35岁以上&apos; 项目, 3 sort from dual</span><br><span class="line">) tt on t.项目=tt.项目</span><br><span class="line">group by tt.项目 ,tt.sort</span><br><span class="line">order by tt.sort</span><br><span class="line">) tc</span><br></pre></td></tr></table></figure></p><p>上面sql语句中的sys_permCode是当前所拥有的科室的权限数据，用于分科室统计其中的数据信息。</p><p>由于统计的需求，需要将没有数据的行也展示出来，所以使用<code>union</code>得到对所有列头的枚举，以及排序字段，再通过<code>right join</code>语句合并到主查询之中。</p><p>这种方式比起第一种有一个比较严重的问题，就是没法生成总计行。（就在整理内容准备写这篇文章的当口，我好像找到了解决这个问题的办法）当时由于进度的原因就只能想了个折中方法，在service层中，对取得的数据做一次手动的统计，也是无奈之举。</p><p>不过这两天得空，重新思考了一下sql语句的结构，发现可以在子查询里拼装，而不是在right join字句或是结果集中添加，变动后的语句如下(原语句内容太多了，做了一点删减)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">with tempStatsData as(select</span><br><span class="line">(case  when trunc(months_between(to_date(&apos;2018-05-04&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=0 and trunc(months_between(to_date(&apos;2018-05-04&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&lt;=18 then &apos;19岁以下&apos;</span><br><span class="line">when trunc(months_between(to_date(&apos;2018-05-04&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=26 then &apos;26岁以上&apos;</span><br><span class="line">when trunc(months_between(to_date(&apos;2018-05-04&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&gt;=19 and trunc(months_between(to_date(&apos;2018-05-04&apos;,&apos;yyyy-MM-dd&apos;),b.csrq)/12)&lt;=25 then &apos;19~25岁&apos; else null end) 项目,</span><br><span class="line">(case when b.sys_permCode = &apos;#&apos; then 1 else 0 end) keshi0,   /*这个code的具体内容在这个例子中不重要，所以直接省略了，用#代替*/</span><br><span class="line">(case when b.sys_permCode = &apos;#&apos; then 1 else 0 end) keshi1,</span><br><span class="line">(case when b.sys_permCode = &apos;#&apos; then 1 else 0 end) keshi2,</span><br><span class="line">from pp_worker_base_info b where 1=1</span><br><span class="line">and b.sys_permCode in (&apos;#&apos;,&apos;#&apos;,&apos;#&apos;))</span><br><span class="line">select tc.项目,nvl(keshi0,0) keshi0,nvl(keshi1,0) keshi1,nvl(keshi2,0) keshi2,nvl(合计,0) 人数,百分比</span><br><span class="line">from (</span><br><span class="line">select &apos;总计&apos; 项目,0 sort,sum(keshi0) keshi0,sum(keshi1) keshi1,sum(keshi2) keshi2,count(t.项目) 合计, null 百分比 from tempStatsData t</span><br><span class="line">union</span><br><span class="line">select tt.项目 项目,sort,sum(t.keshi0) keshi0,sum(t.keshi1) keshi1,sum(t.keshi2) keshi2,count(t.项目) 合计,decode(count(t.项目),0,0,round(count(t.项目) * 100 / sum(count(t.项目)) over(),2)) 百分比 from tempStatsData t  </span><br><span class="line">right join( select &apos;19岁以下&apos; 项目, 1 sort from dual</span><br><span class="line">union  </span><br><span class="line">select &apos;26岁以上&apos; 项目, 3 sort from dual</span><br><span class="line">union  </span><br><span class="line">select &apos;19~25岁&apos; 项目, 2 sort from dual</span><br><span class="line">) tt on t.项目=tt.项目</span><br><span class="line">group by tt.项目, tt.sort</span><br><span class="line">) tc</span><br><span class="line">order by tc.sort;</span><br></pre></td></tr></table></figure></p><p>其实关键就是要分清楚查询与子查询级数的问题，子查询的结果集能够作为外层查询的数据源，当不能够一次性得到自己需要的数据时，使用子查询可以很好的处理，但是在写的时候要十分注意嵌套的层数关系，避免在语句多起来以后分不清层级关系，从而出现混乱和错误。</p><h3 id="提高篇"><a href="#提高篇" class="headerlink" title="提高篇"></a>提高篇</h3><ul><li>留待以后</li></ul><h3 id="结语篇"><a href="#结语篇" class="headerlink" title="结语篇"></a>结语篇</h3><p>这次的这篇博客因为一些原因，断断续续写了大半个月才（半）完成，思路实在是续不上来，但又不想让努力付诸东流，于是草草写完，中间的好多东西完整性都不够，也没有深度，但是也只能就这样了。希望能看到这里的人见谅。</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>纪念512十周年有感</title>
      <link href="/2018/05/12/180512/"/>
      <content type="html"><![CDATA[<a id="more"></a><blockquote><p>一言以蔽之，曰：无知者无畏。</p></blockquote><p>其实我是不太愿意主动去回忆过往的，因为每次都会很嫌弃那时的自己。所以那些年的记忆淡的像一碗清茶，比白开水多点苦味，只有当别人谈起时，搅动起沉在碗底的茶渣，才又有了些模糊的印象，再慢慢的凭着推理整理出事情的大概。听人说到那晚的雨，才想起确实有那么一场雨，想起那个凉亭；又有人提到雨大，才想起为了躲雨去了保安室。再后来，彻夜未眠吗，忘了。</p><p>那年我五年级，从还记得的一些片段发现，我那时候脑子大概是90%的玩和10%其他构成的。虽然不大愿意承认，但是一直到往后的好几年里构成比例都没有过太大的变动。</p><p>说到那场地震，第一个浮现在脑海里的画面，是同学们挤在教室门口想出去，而我在站在后面的讲台上看着。因为临走之前还把课桌上的游戏王卡片收了起来，落在了后面，于是干脆自暴自弃的就最后一个离开教室了。在跑到空地上以后，被晃得站不稳，于是蹲在了红色的地砖上，那一刻，我知道了地震是波。后来跟着二姨家住在东河边的帐篷里，下雨的时候就拿着竿子桶棚顶的积水玩，能玩一天，不下雨的时候，就沿着河岸来来回回地走，想找到个认识的人，才好玩。再往后，能偶尔回去一趟了，我总是最积极的那个，回去的第一件事，一定是打开电脑。</p><p>国家降半旗之后似乎还有三天禁娱的事，我。。</p><p>我想我可能没救了。</p><p>剩下的10%和玩无关的事情，也是诸如“地震一个多月假期里老师布置的作业我用最后几天赶完到了返校当天大家都说没做老师觉得情有可原作业不收了”这种。</p><p>这就是我不大愿意回忆起往事的原因。</p><p>扯远了。</p><p>那时我还很爱哭，跟人打了架会哭，受伤了会哭，受了委屈会哭。但是好像理解不到生离死别的伤感，真正离别的时候反而没有哭。</p><p>我还能想起一些报道，但那个年纪的我到底有没有因此哭过，我真的，真的，真的忘了。</p><p>再后来，我跟人打了架，受了伤，受了委屈都不会哭了，却会在某个瞬间泪流满面。这份痛楚里，还加了一点对那时的自己的埋怨。</p><p>所以我不太想回忆以往的事。</p>]]></content>
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>volatile机制探究</title>
      <link href="/2018/04/01/180401/"/>
      <content type="html"><![CDATA[<blockquote><p>看了别人的几篇博客，觉得受益匪浅，同时有一点自己的想法，想记录下来，便有了这篇博文。<br><a id="more"></a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>多线程主要围绕的问题就是可见性，原子性和有序性这些特性。而使用volatile关键字修饰的变量，能够保证其在多线程之间的可见性，即每次读取到的volatile变量，一定是最新的数据。<br>volatile同时也会阻止进行语句重排。</p><p>从内存模型说起，在java虚拟机中，程序计数器 java虚拟机栈 本地方法栈都是线程私有的，方法区和java堆是线程公有的。各种数据在内存中存放的位置：</p><p>局部变量，是指在方法中定义的基本类型的变量和引用类型的指针，都在方法的栈内存中分配空间，当方法运行完成时，内存被施放。成员变量，在所在类未被初始化（能不能用初始化这个词？）时，作为类的字段信息存放在方法区中，类实例化成对象后，存放在堆中。静态变量（类变量）放在方法区中，常量存放在运行时常量池中（运行时常量池jdk1.7以后被放在了java堆中）</p><p>当java的线程需要对公有数据进行操作时，会将主内存中的数据拷贝到工作内存中再进行操作，执行成功后再将数据写回主内存中，这样的操作方式很容易发生在多个线程同时操作一个公有数据时，因为读写的不同步导致执行发生不可预料的错误，例如脏读。</p><p>在下面的这个示例程序中，有一个成员变量bChanged，这个变量会被一个线程不停修改，而在另一个线程中不做改动，只进行一个<code>bChanged==!bChanged</code>的判断。在没有使用volatile关键字时，<code>bChanged==!bChanged</code>判断的结果一直为<code>false</code>，不会执行任何输出。而当使用了volatile关键字修饰变量之后，会有输出出现。</p><p>这里只放有volatile的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DirtyRead &#123;</span><br><span class="line"></span><br><span class="line">public static volatile boolean bChanged = false;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">if(bChanged == !bChanged)&#123;</span><br><span class="line">System.out.println(&quot;bChanged == !bChanged&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">Thread.sleep(1);</span><br><span class="line">new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">bChanged = !bChanged;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行后的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bChanged == !bChanged</span><br><span class="line">bChanged == !bChanged</span><br><span class="line">bChanged == !bChanged</span><br><span class="line">bChanged == !bChanged</span><br><span class="line">···</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>做一个<code>bChanged == !bChanged</code>的判断竟然结果能为真，看起来很扯，但是其实这就是volatile这个关键字的作用。</p><p>两种特性：</p><ol><li>保证此变量对所有线程的可见性。即当某个线程修改了这个变量的值，这个新的值能够立刻同步到主内存中，且使其他线程中的缓存无效，其他线程使用这个值前会从主存刷新。（也就是说声明了volatile后，每次读变量的操作都是从内存中读，跳过了CPU cache）</li><li>禁止指令重排序优化。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>处理器为了提高处理速度，不直接和内存进行通讯，而是会将系统内存的数据读到内部缓存（CPU L1L2 cache或者其他）之后再进行操作，操作完成后写回到内存的时间不确定。</p><p>对声明了volatile的变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令（lock前缀的指令在多核处理器下会引发两件事，将当前处理器缓存行的数据写回到系统内存，这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效），将这个变量所在缓存行的数据写回系统内存。这一步就能够保证将对变量的修改更新到主存中。</p><p>但是这个时候其他处理器的缓存还是旧的，所以在多处理器的环境下，为了保证各个处理器缓存一致，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据堵到处理器缓存里。这一步保证了其他线程得到的变量都是新的。</p><p>这里参考了<a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">聊聊并发（一）深入分析Volatile的实现原理</a>中对底层原理的描述，但是因为还是挺繁琐的，就自己简化了一下描述，想了解完整内容的可以去这个网址看一看。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>但是volatile只保证有序性和可见性，比起其他的同步方式例如synchronouse少了一个原子性。他只能保证在读取这个变量使用时能够得到最新的数据，由于没有原子性，并不能保证在使用的过程中值不变。比如在上面的那个例子中，<code>bChanged == !bChanged</code>有时会被判断为true，就是因为在java的指令执行时，先取得了第一个bChanged的值放进内存，然后取第二个bChanged的值，在这两次操作之中，bChanged的值在另一个线程中发生了改变，于是读取出来的值也就发生了变化，就出现了上面的那种情况。</p><p>为了更好地说明他不具备原子性，写了下面这个例子来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">volatile int i = 0;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j = 0; j &lt; 10000; j++)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">VolatileDemo v = new VolatileDemo();</span><br><span class="line">Thread t1 = new Thread(v);</span><br><span class="line">Thread t2 = new Thread(v);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(&quot;the value of i :&quot;+v.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the value of i :12630</span><br></pre></td></tr></table></figure></p><p>虽然执行的结果有很大的随机性，但是多次执行以后发现这个值是远小于20000的。这就是因为<code>i++</code>这个操作不是原子操作，相当于<code>i = i + 1</code>，会进行取值、加一、赋值这几个操作，在他进入一次自增操作到自增结束的这段时间中，不会对主存中的数值进行修改，另一个线程在这个时间段中进行的自增操作读取的还是没有修改前的数值，导致这两次自增过后写入主存的是同一个值。就在报道上出现了偏差。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>由我的上一段话可以知道，volatile这个关键字只是一种轻量级的同步机制，并不具备锁的特性，虽然不会阻塞线程的执行，但是也没办法保证多线程之间的安全性。所以这个关键字具有和普通的锁不同的使用场景。</p><p>在需要使用volatile变量的地方，主要看重的是其简易性，在某些情况下，volatile变量要比使用相应的锁简单得多。其次是性能的原因，某些情况下，volatile变量同步机制的性能要优于锁。（之所以说是在“某些情况下”，是因为对于操作的具体开销，很难做出准确的评价，因为单纯进行volatile和synchronouse的比较是很难的。但是，因为我们能够了解到在大多数的处理器架构下，volatile的读操作开销非常低，写操作的开销更高，虽然还是比获取锁低。所以，当读操作的次数远大于写操作 的次数时，使用volatile是更好的选择）</p><p>使用volatile的场景的条件：</p><ol><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>通过这两个条件能得出一个结论，volatile适合用作对于变量当前状态的判断上，不能用来做多个线程之间的计数器。</p><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><p>在当一个变量用作布尔状态标志时，为了确保及时获得最新的变量值，可以使用volatile关键词，同时由于作为状态判断标志，读的次数是远大于写的，效率上也能够满足要求。</p><h3 id="一次性安全发布（one-time-safe-publication）"><a href="#一次性安全发布（one-time-safe-publication）" class="headerlink" title="一次性安全发布（one-time safe publication）"></a>一次性安全发布（one-time safe publication）</h3><p>在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。本文最上面的示例代码就发生了这种情况。这里就不得不提到著名的双重检查锁定（double-checked-locking）问题了。</p><p>双重检查模式一般是在需要对实例域使用延迟初始化时，为了兼顾性能能考虑使用的一种方式。《Effective Java》这本书中也提到了这个东西，所以我们这里就用书里给的例子来加以说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//延迟初始化的同步方法实现，这是实现起来最简单的一种</span><br><span class="line">//Lazy initialization of instance field - synchronized accessor</span><br><span class="line">private FieldType field;</span><br><span class="line"></span><br><span class="line">synchronized FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        field = computeFieldValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是在性能上，由于每次使用getField()方法都需要加锁，访问这个实例的开销会很大。</p><p>为了优化性能，缩小同步的范围，从对方法的同步缩小到对代码块进行加锁同步。这就是要使用双重检查模式的场景了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private FieldType field;</span><br><span class="line"></span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        cynchronized(this)&#123;</span><br><span class="line">            if(field == null)</span><br><span class="line">                field = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而上面这段代码实际上是不能够有效工作的。不起作用的原因在于编译器对指令进行了重新排序，在这篇文章中不对此内容做更细致的探讨。</p><p>但是为了避免这种情况的出现，在进行第二次检查锁定的同时，增加一个赋值语句来抵消指令重排的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Double-check idiom for lazy initialization of instance fields</span><br><span class="line">private FieldType field;</span><br><span class="line"></span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        FieldType result;</span><br><span class="line">        cynchronized(this)&#123;</span><br><span class="line">            result = field;</span><br><span class="line">            if(result == null)</span><br><span class="line">                field = result = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是实际上这种方式也是不起作用的，这个就触及到我的知识盲区了，看别人的说法是同步规则的问题，现在的我也不是太懂，先挖个坑，以后有机会在填。</p><p>所以双重检查模式还是使用volatile关键字来解决，因为在jdk5以后，增强了volatile的语义，不允许volatile读操作与其后面的读写操作进行指令重排序。所以使用volatile实现的代码版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private volatile FieldType field;</span><br><span class="line"></span><br><span class="line">FieldType getField()&#123;</span><br><span class="line">    if(field == null)&#123;</span><br><span class="line">        cynchronized(this)&#123;</span><br><span class="line">            if(field == null)</span><br><span class="line">                field = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独立观察-independent-observation"><a href="#独立观察-independent-observation" class="headerlink" title="独立观察(independent observation)"></a>独立观察(independent observation)</h3><p>这种方式模式是定期“公布”观察结果供程序内部使用。例如，如下代码的功能是使用身份验证机制记忆最后一次登录用户的名字，并使用lastUser来引用发布值，供程序其他部分调用，使用volatile的作用可以保证值能够得到及时的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class UserManager &#123;</span><br><span class="line">    public volatile String lastUser;</span><br><span class="line"></span><br><span class="line">    public boolean authenticate(String user, String password) &#123;</span><br><span class="line">        boolean valid = passwordIsValid(user, password);</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            User u = new User();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        return valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="volatile-bean模式"><a href="#volatile-bean模式" class="headerlink" title="volatile bean模式"></a>volatile bean模式</h3><p>就是将JavaBean中的成员变量用volatile修饰，这样做的原因是很多框架为易变数据的持有者（例如HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。</p><h3 id="开销较低的读写锁策略"><a href="#开销较低的读写锁策略" class="headerlink" title="开销较低的读写锁策略"></a>开销较低的读写锁策略</h3><p>当读操作远远多于写操作是，可以结合使用内部所和volatile变量来减少公共代码路径的开销。因为volatile不具有原子性，所以写操作用锁，而读操作只需要保证可见性，于是可以用volatile来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class CheesyCounter &#123;</span><br><span class="line">    // Employs the cheap read-write lock trick</span><br><span class="line">    // All mutative operations MUST be done with the &apos;this&apos; lock held</span><br><span class="line">    @GuardedBy(&quot;this&quot;)</span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123; return value; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized int increment() &#123;</span><br><span class="line">        return value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里部分内容来自<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">正确使用Volatile变量</a>，有兴趣的可以去原博探究一下详细内容。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>volatile作为一种轻量级的同步方式，能够使用的应用场景十分有限，而且在同步的实现上相对比其他方式更容易出现错误，然而在适当的场景做出合理的使用，仍旧是可以达到提高性能的作用。所以，对volatile有足够的了解，找到合适的场景，两者缺一不可。</p>]]></content>
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Java中精确计算的问题</title>
      <link href="/2018/03/20/180320/"/>
      <content type="html"><![CDATA[<blockquote><p>世界上有10种人，一种是懂二进制的，一种是不懂二进制的<br><a id="more"></a></p></blockquote><h2 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h2><p>之前看公司的代码发现有一个提供精确运算的工具类。想起以前确实有听说过浮点数用于计算精确度丢失的问题，但一直是知其然不知其所以然，如今有这个机会，就想着深入的学习一下这方面的相关东西。</p><p>由于计算机对于大小的比较会严格按照值的大小进行。计算时会有误差出现，这种误差会导致进行数值比较时出错。例如计算机不会认为0.9999999等于1。</p><h2 id="找到的答案"><a href="#找到的答案" class="headerlink" title="找到的答案"></a>找到的答案</h2><p>查阅资料发现，原因在于进制的转换问题，在一些情况下十进制数的二进制表示形式可能不够精确。首先，对于十进制的整数，转换成二进制以后是能够除尽的，所以整数能够用二进制精度表示。问题出在小数这里，就像十进制数也有除不尽的数一样，二进制同样存在，而且是一些在十进制下能除尽的数使用二进制无法除尽，在这个进制下是无限小数，超过表示的位数之后就会将之后的部分舍弃，这样就会导致明明精准输入的数在二进制下不够精准，也就出现了精度的丢失。</p><p>这个进制真的也是很神奇的东西，将十进制向二进制转换，整数部分使用“除二取余法”，小数部分使用的是“乘二取整法”，那么要使得确保精度，小数部分的末位就应该是5的倍数。其他时候精度丢失就出现了。</p><p>然而精度的丢失发生在哪一个阶段呢，我们写几行代码看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double g = 0.05;</span><br><span class="line">double h = 0.01;</span><br><span class="line"></span><br><span class="line">System.out.println(h + g);</span><br><span class="line">System.out.println(&quot;test: &quot; + g);</span><br></pre></td></tr></table></figure></p><p>我们可以发现输出的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.060000000000000005</span><br><span class="line">test: 0.05</span><br></pre></td></tr></table></figure></p><p>通过代码来看，精度丢失似乎是发生在运算阶段，然而事实却并非如此。当不进行浮点运算时，可以直接使用定义时给的十进制表示方法，而运算后值发生了精确度上的变化，是因为本身参与运算的值就已经不够精确，在进行运算后，产生了不可预知的结果。</p><p><strong>根据以上得出的结论就是：计算机中的浮点数都是以二进制进行的运算，对于部分由十进制转化为二进制的数由于在进制转化时无法除尽，对相应的二进制数只是一个近似值。所以当使用这种浮点数计算后，将其转换回十进制就会出现很小的误差。这种误差和原始数据是差了很多个数量级的，对数值大小的影响小，但是会影响数值比较时做出的判断。</strong></p><p>所以其实浮点数只适合用于科学计算而不适用于精确计算。在《effective java》 中，也提到了这个原则。（回去找一找看一看再写这个部分）  ： float和剁手了类型主要是为了科学计算和工程计算而设计的，它们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算，不应该被用于需要精确结果的场合</p><h2 id="Java中的解决方案"><a href="#Java中的解决方案" class="headerlink" title="Java中的解决方案"></a>Java中的解决方案</h2><p>那么在java中如何进行精确的小数运算呢，bigdecimal。</p><p>使用BigDecimal并且一定要用String来构造。举个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 提供精确的加法运算。</span><br><span class="line">* @param v1 被加数</span><br><span class="line">* @param v2 加数</span><br><span class="line">* @return 两个参数的和</span><br><span class="line">*/  </span><br><span class="line">//双精度或者浮点类型要转换成String类型再计算  </span><br><span class="line">public static BigDecimal add(double v1, double v2) &#123;  </span><br><span class="line">BigDecimal b1 = new BigDecimal(Double.toString(v1));  </span><br><span class="line">BigDecimal b2 = new BigDecimal(Double.toString(v2));  </span><br><span class="line">return b1.add(b2);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public static BigDecimal add(String v1, String v2) &#123;  </span><br><span class="line">BigDecimal b1 = new BigDecimal(v1);  </span><br><span class="line">BigDecimal b2 = new BigDecimal(v2);  </span><br><span class="line">return b1.add(b2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用BigDecimal还有一些额外的好处，比如可以完全按照自己的想法控制舍入，BigDecimal本身提供了几种舍入模式，选择一种使用十分方便。此外在数字大小超过18位时，也必须使用BigDecimal</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdecimal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Springboot：Spring Data Jpa的使用</title>
      <link href="/2018/03/13/180313/"/>
      <content type="html"><![CDATA[<p>使用spring data jpa 开发时，发现国内对spring boot jpa全面介绍的文章比较少案例也比较零碎，因此写文章总结一下。<br><a id="more"></a></p><h2 id="spring-data-jpa-介绍"><a href="#spring-data-jpa-介绍" class="headerlink" title="spring data jpa 介绍"></a>spring data jpa 介绍</h2><hr><h3 id="首先了解JPA是什么"><a href="#首先了解JPA是什么" class="headerlink" title="首先了解JPA是什么"></a>首先了解JPA是什么</h3><p>JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。他的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，JPA受到了极大的支持和赞扬，其中就包括了Spring与EJB3.0的开发团队。</p><blockquote><p>注意:JPA是一套规范，不是一套产品，那么像Hibernate,TopLink,JDO他们是一套产品，如果说这些产品实现了这个JPA规范，那么我们就可以叫他们为JPA的实现产品。</p></blockquote><h3 id="spring-data-jpa"><a href="#spring-data-jpa" class="headerlink" title="spring data jpa"></a>spring data jpa</h3><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</p><blockquote><p>spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现</p></blockquote><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><hr><p>基本查询也分为两种，一种是spring data默认已经实现，一种是根据查询的方法来自动解析成SQL。</p><h3 id="预先生成方法"><a href="#预先生成方法" class="headerlink" title="预先生成方法"></a>预先生成方法</h3><p>spring data jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等</p><ol><li><p>继承JpaRepository</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用默认方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testBaseQuery() throws Exception &#123;</span><br><span class="line">User user=new User();</span><br><span class="line">userRepository.findAll();</span><br><span class="line">userRepository.findOne(1l);</span><br><span class="line">userRepository.save(user);</span><br><span class="line">userRepository.delete(user);</span><br><span class="line">userRepository.count();</span><br><span class="line">userRepository.exists(1l);</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>就不解释了根据方法名就能看出意思来</p><h3 id="自定义简单查询"><a href="#自定义简单查询" class="headerlink" title="自定义简单查询"></a>自定义简单查询</h3><p>自定义的简单查询就是根据方法名来自动生成SQL，主要的语法是<code>findXXBy</code>,<code>readAXXBy</code>,<code>queryXXBy</code>,<code>countXXBy</code>, <code>getXXBy</code>后面跟属性名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUserName(String userName);</span><br></pre></td></tr></table></figure></p><p>也使用一些加一些关键字<code>And</code>、 <code>Or</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User findByUserNameOrEmail(String username, String email);</span><br></pre></td></tr></table></figure></p><p>修改、删除、统计也是类似语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long deleteById(Long id);</span><br><span class="line"></span><br><span class="line">Long countByUserName(String userName)</span><br></pre></td></tr></table></figure></p><p>基本上SQL体系中的关键词都可以使用，例如：<code>LIKE</code>、 <code>IgnoreCase</code>、 <code>OrderBy</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; findByEmailLike(String email);</span><br><span class="line"></span><br><span class="line">User findByUserNameIgnoreCase(String userName);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findByUserNameOrderByEmailDesc(String email);</span><br></pre></td></tr></table></figure></p><p><strong>具体的关键字，使用方法和生产成SQL如下表所示</strong></p><table><thead><tr><th>Keyword</th><th>Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td>And</td><td>findByLastnameAndFirstname</td><td>… where x.lastname = ?1 and x.firstname = ?2</td></tr><tr><td>Or</td><td>findByLastnameOrFirstname</td><td>… where x.lastname = ?1 or x.firstname = ?2</td></tr><tr><td>Is,Equals</td><td>findByFirstnameIs,findByFirstnameEquals</td><td>… where x.firstname = ?1</td></tr><tr><td>Between</td><td>findByStartDateBetween</td><td>… where x.startDate between ?1 and ?2</td></tr><tr><td>LessThan</td><td>findByAgeLessThan</td><td>… where x.age &lt; ?1</td></tr><tr><td>LessThanEqual</td><td>findByAgeLessThanEqual</td><td>… where x.age ⇐ ?1</td></tr><tr><td>GreaterThan</td><td>findByAgeGreaterThan</td><td>… where x.age &gt; ?1</td></tr><tr><td>GreaterThanEqual</td><td>findByAgeGreaterThanEqual</td><td>… where x.age &gt;= ?1</td></tr><tr><td>After</td><td>findByStartDateAfter</td><td>… where x.startDate &gt; ?1</td></tr><tr><td>Before</td><td>findByStartDateBefore</td><td>… where x.startDate &lt; ?1</td></tr><tr><td>IsNull</td><td>findByAgeIsNull</td><td>… where x.age is null</td></tr><tr><td>IsNotNull,NotNull</td><td>findByAge(Is)NotNull</td><td>… where x.age not null</td></tr><tr><td>Like</td><td>findByFirstnameLike</td><td>… where x.firstname like ?1</td></tr><tr><td>NotLike</td><td>findByFirstnameNotLike</td><td>… where x.firstname not like ?1</td></tr><tr><td>StartingWith</td><td>findByFirstnameStartingWith</td><td>… where x.firstname like ?1 (parameter bound with appended %)</td></tr><tr><td>EndingWith</td><td>findByFirstnameEndingWith</td><td>… where x.firstname like ?1 (parameter bound with prepended %)</td></tr><tr><td>Containing</td><td>findByFirstnameContaining</td><td>… where x.firstname like ?1 (parameter bound wrapped in %)</td></tr><tr><td>OrderBy</td><td>findByAgeOrderByLastnameDesc</td><td>… where x.age = ?1 order by x.lastname desc</td></tr><tr><td>Not</td><td>findByLastnameNot</td><td>… where x.lastname &lt;&gt; ?1</td></tr><tr><td>In</td><td>findByAgeIn(Collection ages)</td><td>… where x.age in ?1</td></tr><tr><td>NotIn</td><td>findByAgeNotIn(Collection age)</td><td>… where x.age not in ?1</td></tr><tr><td>TRUE</td><td>findByActiveTrue()</td><td>… where x.active = true</td></tr><tr><td>FALSE</td><td>findByActiveFalse()</td><td>… where x.active = false</td></tr><tr><td>IgnoreCase</td><td>findByFirstnameIgnoreCase</td><td>… where UPPER(x.firstame) = UPPER(?1)</td></tr></tbody></table><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><hr><p>在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义SQL</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>分页查询在实际使用中非常普遍了，spring data jpa已经帮我们实现了分页的功能，在查询的方法中，需要传入参数<code>Pageable</code> ,当查询中有多个参数的时候<code>Pageable</code>建议做为最后一个参数传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; findALL(Pageable pageable);</span><br><span class="line"></span><br><span class="line">Page&lt;User&gt; findByUserName(String userName,Pageable pageable);</span><br></pre></td></tr></table></figure></p><p><code>Pageable</code>是spring封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPageQuery() throws Exception &#123;</span><br><span class="line">int page=1,size=10;</span><br><span class="line">Sort sort = new Sort(Direction.DESC, &quot;id&quot;);</span><br><span class="line">    Pageable pageable = new PageRequest(page, size, sort);</span><br><span class="line">    userRepository.findALL(pageable);</span><br><span class="line">    userRepository.findByUserName(&quot;testName&quot;, pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>限制查询</strong><br>有时候我们只需要查询前N个元素，或者支取前一个实体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ser findFirstByOrderByLastnameAsc();</span><br><span class="line"></span><br><span class="line">User findTopByOrderByAgeDesc();</span><br><span class="line"></span><br><span class="line">Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);</span><br></pre></td></tr></table></figure></p><h3 id="自定义SQL查询"><a href="#自定义SQL查询" class="headerlink" title="自定义SQL查询"></a>自定义SQL查询</h3><p>其实Spring data 觉大部分的SQL都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的SQL来查询，spring data也是完美支持的；在SQL的查询方法上面使用<code>@Query</code>注解，如涉及到删除和修改在需要加上<code>@Modifying</code>.也可以根据需要添加 <code>@Transactional</code> 对事物的支持，查询超时的设置等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Modifying</span><br><span class="line">@Query(&quot;update User u set u.userName = ?1 where u.id = ?2&quot;)</span><br><span class="line">int modifyByIdAndUserId(String  userName, Long id);</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">@Modifying</span><br><span class="line">@Query(&quot;delete from User where id = ?1&quot;)</span><br><span class="line">void deleteByUserId(Long id);</span><br><span class="line"></span><br><span class="line">@Transactional(timeout = 10)</span><br><span class="line">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span><br><span class="line">    User findByEmailAddress(String emailAddress);</span><br></pre></td></tr></table></figure></p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询在spring data jpa中有两种实现方式，第一种是利用hibernate的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。</p><p>首先需要定义一个结果集的接口类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface HotelSummary &#123;</span><br><span class="line"></span><br><span class="line">City getCity();</span><br><span class="line"></span><br><span class="line">String getName();</span><br><span class="line"></span><br><span class="line">Double getAverageRating();</span><br><span class="line"></span><br><span class="line">default Integer getAverageRatingRounded() &#123;</span><br><span class="line">return getAverageRating() == null ? null : (int) Math.round(getAverageRating());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查询的方法返回类型设置为新创建的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select h.city as city, h.name as name, avg(r.rating) as averageRating &quot;</span><br><span class="line">- &quot;from Hotel h left outer join h.reviews r where h.city = ?1 group by h&quot;)</span><br><span class="line">Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable);</span><br><span class="line"></span><br><span class="line">@Query(&quot;select h.name as name, avg(r.rating) as averageRating &quot;</span><br><span class="line">- &quot;from Hotel h left outer join h.reviews r  group by h&quot;)</span><br><span class="line">Page&lt;HotelSummary&gt; findByCity(Pageable pageable);</span><br></pre></td></tr></table></figure></p><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, &quot;name&quot;));</span><br><span class="line">for(HotelSummary summay:hotels)&#123;</span><br><span class="line">System.out.println(&quot;Name&quot; +summay.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在运行中Spring会给接口（HotelSummary）自动生产一个代理类来接收返回的结果，代码汇总使用getXX的形式来获取</p></blockquote><h2 id="多数据源的支持"><a href="#多数据源的支持" class="headerlink" title="##多数据源的支持"></a>##多数据源的支持</h2><h3 id="同源数据库的多元支持"><a href="#同源数据库的多元支持" class="headerlink" title="同源数据库的多元支持"></a>同源数据库的多元支持</h3><p>日常项目中因为使用的分布式开发模式，不同的服务有不同的数据源，常常需要在一个项目中使用多个数据源，因此需要配置sping data jpa对多数据源的使用，一般分一下为三步：</p><ul><li>1 配置多数据源</li><li>2 不同源的实体类放入不同包路径</li><li>3 声明不同的包路径下使用不同的数据源、事务支持</li></ul><p>这里有一篇文章写的很清楚：<a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">Spring Boot多数据源配置与使用</a></p><h3 id="异构数据库多源支持"><a href="#异构数据库多源支持" class="headerlink" title="异构数据库多源支持"></a>异构数据库多源支持</h3><p>比如我们的项目中，即需要对mysql的支持，也需要对mongodb的查询等。</p><p>实体类声明<code>@Entity</code> 关系型数据库支持类型、声明<code>@Document</code> 为mongodb支持类型，不同的数据源使用不同的实体就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Document</span><br><span class="line">public class User &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，如果User用户既使用mysql也使用mongodb呢，也可以做混合使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Document</span><br><span class="line">public class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以通过对不同的包路径进行声明，比如A包路径下使用mysql,B包路径下使用mongoDB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaRepositories(basePackages = &quot;com.neo.repositories.jpa&quot;)</span><br><span class="line">@EnableMongoRepositories(basePackages = &quot;com.neo.repositories.mongo&quot;)</span><br><span class="line">interface Configuration &#123; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr><p><strong>使用枚举</strong></p><p>使用枚举的时候，我们希望数据库中存储的是枚举对应的String类型，而不是枚举的索引值，需要在属性上面添加    <code>@Enumerated(EnumType.STRING)</code>注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Enumerated(EnumType.STRING)</span><br><span class="line">@Column(nullable = true)</span><br><span class="line">private UserType type;</span><br></pre></td></tr></table></figure></p><p><strong>不需要和数据库映射的属性</strong></p><p>正常情况下我们在实体类上加入注解<code>@Entity</code>，就会让实体类和表相关连如果其中某个属性我们不需要和数据库来关联只是在展示的时候做计算，只需要加上<code>@Transient</code>属性既可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Transient</span><br><span class="line">private String  userName;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank" rel="noopener">Spring Data JPA - Reference Documentation</a></p><p><a href="https://www.gitbook.com/book/ityouknow/spring-data-jpa-reference-documentation/details" target="_blank" rel="noopener">Spring Data JPA——参考文档 中文版</a></p><hr><p>作者：纯洁的微笑<br>出处：<a href="http://www.ityouknow.com/springboot/2016/08/20/springboot(%E4%BA%94" target="_blank" rel="noopener">http://www.ityouknow.com/</a>-spring-data-jpa%E7%9A%84%E4%BD%BF%E7%94%A8.html)<br>版权所有，欢迎保留原文链接进行转载：)</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带重复元素以及不带重复元素的全排列</title>
      <link href="/2018/03/09/180309/"/>
      <content type="html"><![CDATA[<blockquote><p>被一块石头绊倒两次是真的丢人——不写引子不舒服斯基<br><a id="more"></a></p></blockquote><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>递归的思想中有几个很重要的特性，对于使用递归求解的问题，把握好这几个因素就能把代码写好了。</p><ol><li>终止条件。递归的方法有一个最终的终止条件，这个条件满足题目所提出的要求，而且不会无限的循环下去。</li><li>子问题。问题中的子问题可以再次递归调用方法求解。这就是分治思想的运用了。在没有满足返回条件之前，每一步和前一步都只是在状态上有不同。</li></ol><h2 id="不带重复元素的"><a href="#不带重复元素的" class="headerlink" title="不带重复元素的"></a>不带重复元素的</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字列表，返回其所有可能的排列。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>你可以假设没有重复数字。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>给出一个列表[1,2,3]，其全排列为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>不带重复元素这个题是很早之前做的了。思路也大概就是写一个递归方法，在方法中判断是否已经全排列，是的话集合加一并返回，不是的话就循环。</p><p>很简单的递归全排列思路，甚至可以直接点地记下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Permute &#123;</span><br><span class="line">public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums)&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">per(res,list,nums);</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void per(List res,List list,int[] nums)&#123;</span><br><span class="line"></span><br><span class="line">if(list.size() == nums.length)&#123;</span><br><span class="line">res.add(new ArrayList(list));</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i = 0;i &lt; nums.length; i++)&#123;</span><br><span class="line">if(list.contains(nums[i]))</span><br><span class="line">continue;</span><br><span class="line">list.add(nums[i]);</span><br><span class="line">per(res,list,nums);</span><br><span class="line">list.remove(list.size()-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带重复元素的"><a href="#带重复元素的" class="headerlink" title="带重复元素的"></a>带重复元素的</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给出一个具有重复数字的列表，找出列表所有不同的排列。</p><p>给出列表 [1,2,2]，不同的排列有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,1,2],</span><br><span class="line">  [2,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>和上面的解法基本上一样，只是要多加一个visited数组来记录这个数据在这一次逐渐深入的递归中是否被使用过，递归返回时改回未被使用。因为允许列表元素重复，所以进行一次普通的全排列后，可能会出现两个相同的排列，为了避免出现重复的排列，所以要进行一次contains的判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class PermuteUnique &#123;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums)&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">int[] visited = new int[nums.length];</span><br><span class="line">permute(0,nums.length,ret,temp,nums,visited);</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用来做递归的子方法，可以当模版参考</span><br><span class="line"> *</span><br><span class="line"> * @param k 当前长度</span><br><span class="line"> * @param n 每个的长度，nums.length</span><br><span class="line"> * @param ret 返回的那个list</span><br><span class="line"> * @param temp 每一次递归用的list</span><br><span class="line"> * @param nums 初始数组</span><br><span class="line"> * @param visited 元素是否被访问过</span><br><span class="line"> */</span><br><span class="line">public void permute(int k,int n,List ret,List temp,int[] nums,int[] visited)&#123;</span><br><span class="line">if(k == n &amp;&amp; !ret.contains(temp))&#123;</span><br><span class="line">ret.add(new ArrayList(temp));</span><br><span class="line">&#125;</span><br><span class="line">if(k &gt; n)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(int i = 0;i &lt; n;i++)&#123;</span><br><span class="line">int pre = nums[i];</span><br><span class="line">if(visited[i] == 0)&#123;</span><br><span class="line">temp.add(pre);</span><br><span class="line">visited[i] = 1;</span><br><span class="line">permute(k + 1,n,ret,temp,nums,visited);</span><br><span class="line">visited[i] = 0;</span><br><span class="line">temp.remove(temp.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一份代码中还有一些地方是可以优化的，比如那个参数n就是完全多于的东西，按照上一份代码其实这个参数是可以不用的，包括k也是，明明就是一个list.size的事，但是当时写代码的时候本着跑起来再说的想法，没有考虑这些问题，虽然之后发现了，但是本着提醒自己的想法，就把没改的版本贴到了这个博客中。</p><h3 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h3><p>这个，偷个懒，以后再说。</p><h2 id="指针问题"><a href="#指针问题" class="headerlink" title="指针问题"></a>指针问题</h2><p>说到指针，按理说学了这么几年已经不应该再在这种事上糊涂了，但是还是犯了错，做之前全排列的那个题时愣是没想通，好在今天做这个题的时候反应过来了，所以借此机会记录一下。</p><p>上面的递归代码中，当排序好的List要放入总的集合中时，之前的我是这样操作的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(k == n &amp;&amp; !ret.contains(temp))&#123;</span><br><span class="line">    //stupid</span><br><span class="line">    ret.add(temp);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><p>用这种add，执行后你会发现结果会大错特错。而应该换用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(k == n &amp;&amp; !ret.contains(temp))&#123;</span><br><span class="line">ret.add(new ArrayList(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对，没错。</p><p>使用上面那个错误操作所存进集合中的并不是一个对象，而是指向这个List对象的指针。这就引起了问题：add进集合中的永远是同一个元素，而且，在带重复元素这道题中，需要进行一次是否已经contains的判断，这个会一直为true，让你甚至连重复元素都加不进去。写代码验证一下这个想法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">temp.add(5);</span><br><span class="line">ret.add(temp);</span><br><span class="line">System.out.println(ret.contains(temp));</span><br><span class="line">temp.add(7);</span><br><span class="line">System.out.println(ret.contains(temp));</span><br><span class="line">ret.add(temp);</span><br><span class="line"></span><br><span class="line">Iterator it = ret.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">[5, 7]</span><br><span class="line">[5, 7]</span><br></pre></td></tr></table></figure></p><p>证明确实如此。所以每次进行add操作时，要new一个新的对象用来存放已经排好序的部分。</p><h2 id="整体感想"><a href="#整体感想" class="headerlink" title="整体感想"></a>整体感想</h2><p>多看，多写，多总结。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>丑数2(Ugly Number Ⅱ)</title>
      <link href="/2018/03/06/180306/"/>
      <content type="html"><![CDATA[<blockquote><p>“今者臣来，见人于大行，方北面而持其驾，告臣曰：’吾欲之楚。’臣曰：‘君之楚，将奚为北面？’曰：‘吾马良。’臣曰：‘马虽良，此非楚之路也。’曰：‘吾用多。’臣曰：‘用虽多，此非楚之路也。’曰：‘吾御者善。’此数者愈善，而离楚愈远耳。”   ——《战国策·魏策四》<br><a id="more"></a></p></blockquote><h2 id="题目：丑数Ⅱ"><a href="#题目：丑数Ⅱ" class="headerlink" title="题目：丑数Ⅱ"></a>题目：丑数Ⅱ</h2><p>设计一个算法，找出只含素因子2，3，5的第n小的数。</p><p>符合条件的数如：1，2，3，5，6，8，9，10，12，15…</p><p>由于观察可以发现，每一个丑数都和之前的一个丑数有关系，因为只含有这几个因子，那么下一个丑数一定是由之前的丑数乘以他的因子得到的。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>因为就只想到了这么多的规律，所以，最初拿到这个题的时候，就以这个规律为解题的思路：对于之前存在的每一个满足条件的数乘以因子数得到之后的数。</p><p>所以最初的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int nthUglyNumber(int n)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;();</span><br><span class="line">al.add(1);</span><br><span class="line">int i = 0;</span><br><span class="line">while(al.size() &lt; n * 2)&#123;</span><br><span class="line">int n2,n3,n4,n5;</span><br><span class="line">n2 = al.get(i) * 2;</span><br><span class="line">n3 = al.get(i) * 3;</span><br><span class="line">n4 = al.get(i) * 4;</span><br><span class="line">n5 = al.get(i) * 5;</span><br><span class="line"></span><br><span class="line">if(!al.contains(n2))&#123;</span><br><span class="line">al.add(n2);</span><br><span class="line">&#125;</span><br><span class="line">if(!al.contains(n3))&#123;</span><br><span class="line">al.add(n3);</span><br><span class="line">&#125;</span><br><span class="line">if(!al.contains(n4))&#123;</span><br><span class="line">    al.add(n4);</span><br><span class="line">&#125;</span><br><span class="line">if(!al.contains(n5))&#123;</span><br><span class="line">al.add(n5);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(al);</span><br><span class="line">Iterator&lt;Integer&gt; it = al.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">return al.get(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种解法看似合情合理，合乎丑数的定义规律，但是仍存在着一定的问题，其实做题时我也发现了，但是以为是能够克服的小问题，最初不太在意导致程序运行出现了问题。</p><ol><li><p>求出的不是最小的丑数。这种方法虽然能够保证求出的都是丑数，但是无法保证这些数出现的顺序，不只是排列顺序的问题，较小的丑数可能会被排在后面的丑数求出。举个例子，由12求得的数为24，36，60，而由15求出的数为30，45，75，16求出的为32，48，80。由这几个数可以看出30，45，32，48都是小于由12求得的60的，而32也是小于45的。这还是数字比较小的时候就出现的顺序错乱，当数字变得很大，数字量很多的时候这种情况会变得更加严重，即使对已经求出的数字进行了排序的操作，也无法判断当前所需要的位置是否是正确的数。这样也就出现了第二个问题。</p></li><li><p>空间和时间的消耗过大。由上一个问题可以发现，如果使用这种方式进行计算，那么为了保证在所求位置的数是满足条件的，它的前面没有出现数据的缺失，那么他的计算量会增大好几倍，而随着数据量的增加，计算的开销也会变得很大。合适能够确定已经达到了所需条件也是一个问题。</p></li></ol><p>在上面的那份代码中可以看到是进行过优化的，比如加入4这个因子，来减小因子差距过大带来的差距，包括把所求的数据扩大到2n也是为了在n处能够是满足条件的那个丑数，但是在数据量很大的时候还是出现了问题，我推断数据量进一步增大问题会更加严峻。而且如果继续扩大这个倍数，例如扩大到3n，那么在数据足够大时，int的长度就会不够用了，再用long的话感觉有点过分。（都是测试时出现的血和泪得来的经验啊T_T）</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>说了那么多关于怎么做错的事情，接下来讲一讲正确的解法。这个解法也是利用丑数性质定义做的，只是思路有点不同：因为每个丑数都是由之前的一个丑数乘以因子得到的，那么下一个丑数就应该是之前的某个丑数乘以因子的最小值。</p><p>这其实感觉是用了动态规划的思想，当前位置的丑数求解看作是一个求之前某些数乘以因子后最小值的状态，每一次求得之后，状态发生了改变但是求解方法并没有发生变化。而且这样只需要求n个数就能够解决问题，是很不错的方法。</p><p>根据这种思路我写了一份代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int nthUglyNumber(int n)&#123;</span><br><span class="line">int[] nums = new int[n];</span><br><span class="line">nums[0] = 1;</span><br><span class="line">int n2 = 0;</span><br><span class="line">int n3 = 0;</span><br><span class="line">int n5 = 0;</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt; n;i++)&#123;</span><br><span class="line">int next = min(nums[n2] * 2,nums[n3] * 3,nums[n5] * 5);</span><br><span class="line">if(next == nums[n2] * 2)&#123;</span><br><span class="line">n2++;</span><br><span class="line">&#125;</span><br><span class="line">if(next == nums[n3] * 3)&#123;</span><br><span class="line">n3++;</span><br><span class="line">&#125;</span><br><span class="line">if(next == nums[n5] * 5)&#123;</span><br><span class="line">n5++;</span><br><span class="line">&#125;</span><br><span class="line">nums[i] = next;</span><br><span class="line">&#125;</span><br><span class="line">return nums[n - 1];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//求最小值</span><br><span class="line">public int min(int i,int j,int k)&#123;</span><br><span class="line">if(i &lt; j)&#123;</span><br><span class="line">return i &lt; k ? i : k;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return j &lt; k ? j : k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一步一步求出来的值就是符合条件的丑数值。</p><h2 id="使用遍历"><a href="#使用遍历" class="headerlink" title="使用遍历"></a>使用遍历</h2><p>其实看网上的博客我发现还有另一种解法，就是进行遍历，对从1开始的每个数挨个查看，检查是否为满足条件的数，检查的方式也是根据丑数的特点：只含有因子2，3，5。如果满足这个条件就认定为是丑数，把计数器加一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean IsUgly(int number)&#123;</span><br><span class="line">    while (number % 2 == 0)&#123;</span><br><span class="line">        number /= 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (number % 3 == 0)&#123;</span><br><span class="line">        number /= 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (number % 5 == 0)&#123;</span><br><span class="line">        number /= 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return number == 1 ? true : false;</span><br></pre></td></tr></table></figure></p><p>这种解法虽然是能够求出结果的，但是在计算量上比我自己的那种解法还大，因为要对所有的数进行是否为丑数的判断，无用的计算量太大，当数字逐渐增大时，在时间上是明显不能够满足题目要求的。</p><h2 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h2><p>素因子可以不为2，3，5，可以换做其他的数，求解的方法也是一样。</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>做题时还是要带上脑子的，特别是一些需要使用所求数据的规律性质的时候要多转一个弯，就像这个题上一样，对于同一个性质，理解方式和侧重点的不同都会使解题的思路不同，结果导致所写出的解法千差万别。找准切入点，找到合适的解法很重要。不然你做的一切不过是南辕北辙。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle官方文档 —— The try-with-resources Statement</title>
      <link href="/2018/02/11/180211/"/>
      <content type="html"><![CDATA[<h2 id="The-try-with-resources-Statement"><a href="#The-try-with-resources-Statement" class="headerlink" title="The try-with-resources Statement"></a>The try-with-resources Statement</h2><p>The try-with-resources statement is a try statement that declares one or more resources. A resource is as an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements <code>java.lang.AutoCloseable</code>, which includes all objects which implement <code>java.io.Closeable</code>, can be used as a resource.<br><a id="more"></a><br>try-with-resources语句是一个声明一个或多个resources的try语句。Resource是指在程序使用结束后必须被关闭的对象。try-with-resources语句保证每个resource都会在语句结束时被关闭。任何实现了<code>java.lang.AutoCloseable</code>和<code>java.io.Closeable</code>接口的对象都可以视作resource。</p><p>The following example reads the first line from a file. It uses an instance of <code>BufferedReader</code> to read data from the file. <code>BufferedReader</code> is a resource that must be closed after the program is finished with it:</p><p>下面这个程序的例子会读取文件的第一行，它使用了<code>BufferedReader</code>的实例来从文件中读取数据。<code>BufferedReader</code>是一个程序使用完以后必须关闭的resource。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static String readFirstLineFromFile(String path) throws IOException &#123;</span><br><span class="line">  try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123;</span><br><span class="line">    return br.readLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In this example, the resource declared in the try-with-resources statement is a <code>BufferedReader</code>. The declaration statement appears within parentheses immediately after the try keyword. The class <code>BufferedReader</code>, in Java SE 7 and later, implements the interface <code>java.lang.AutoCloseable</code>. Because the BufferedReader instance is declared in a try-with-resource statement, it will be closed regardless of whether the try statement completes normally or abruptly (as a result of the method <code>BufferedReader.readLine</code> throwing an IOException).</p><p>在这个例子中，<code>BufferedReader</code>作为resource在try-with-resources语句中被声明，声明语句放在紧跟在try这个关键字后的小括号中。BufferedReader这个类，在Java SE 7以及更后面的版本中实现了<code>java.lang.AutoCloseable</code>这个接口。如果BufferedReader实例在一个try-with-resource的语句中被声明，那么不管try语句是否成功执行这个resource都会被关闭（执行<code>BufferedReader.readLine</code>这个方法的结果是抛出IOExcepetion异常）。</p><p>Prior to Java SE 7, you can use a finally block to ensure that a resource is closed regardless of whether the try statement completes normally or abruptly. The following example uses a finally block instead of a try-with-resources statement:</p><p>在Java SE 7之前的版本里，你可以使用finally块来确保resource在任何情况下都能被关闭，下面的这个例子就是使用finally块代替<code>try-with-resources</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException &#123;</span><br><span class="line">  BufferedReader br = new BufferedReader(new FileReader(path));</span><br><span class="line">  try &#123;</span><br><span class="line">    return br.readLine();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (br != null) br.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, in this example, if the methods readLine and close both throw exceptions, then the method <code>readFirstLineFromFileWithFinallyBlock</code> throws the exception thrown from the finally block; the exception thrown from the try block is suppressed. In contrast, in the example readFirstLineFromFile, if exceptions are thrown from both the try block and the try-with-resources statement, then the method <code>readFirstLineFromFile</code> throws the exception thrown from the try block; the exception thrown from the try-with-resources block is suppressed. In Java SE 7 and later, you can retrieve suppressed exceptions; see the section Suppressed Exceptions for more information.</p><p>然而，在这个例子中，如果方法readLine和close都抛出错误，这时方法readFirstLineFromFileWithFinallyBlock 会抛出finally块中抛出的异常；而来自try语句块中的异常会被抑制。相比之下，在例子readFirstLineFromFile中，如果同时从try语句块和try-with-resources语句中抛出错误，那么这个方法实际会抛出try块中的异常；来自try-with-resources块中的异常会被抑制。在Java SE 7以及之后的版本中，你可以得到被抑制的异常；在Suppressed Exceptions这章节中你可以了解更多。</p><p>You may declare one or more resources in a try-with-resources statement. The following example retrieves the names of the files packaged in the zip file zipFileName and creates a text file that contains the names of these files:</p><p>你可能会在一个try-with-resources语句中声明多个resouces。下面的这个例子会从打包的zip文件zipFileName中获得这些文件的文件名，同时创建一个文本文件来储存这些文件名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void writeToFileZipFileContents(String zipFileName, String outputFileName)</span><br><span class="line">  throws java.io.IOException &#123;</span><br><span class="line"></span><br><span class="line">  java.nio.charset.Charset charset = java.nio.charset.Charset.forName(&quot;US-ASCII&quot;);</span><br><span class="line">  java.nio.file.Path outputFilePath = java.nio.file.Paths.get(outputFileName);</span><br><span class="line"></span><br><span class="line">  // Open zip file and create output file with try-with-resources statement</span><br><span class="line"></span><br><span class="line">  try (</span><br><span class="line">    java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);</span><br><span class="line">    java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)</span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    // Enumerate each entry</span><br><span class="line"></span><br><span class="line">    for (java.util.Enumeration entries = zf.entries(); entries.hasMoreElements();) &#123;</span><br><span class="line"></span><br><span class="line">      // Get the entry name and write it to the output file</span><br><span class="line"></span><br><span class="line">      String newLine = System.getProperty(&quot;line.separator&quot;);</span><br><span class="line">      String zipEntryName = ((java.util.zip.ZipEntry)entries.nextElement()).getName() + newLine;</span><br><span class="line">      writer.write(zipEntryName, 0, zipEntryName.length());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In this example, the try-with-resources statement contains two declarations that are separated by a semicolon: <code>ZipFile</code> and <code>BufferedWriter</code>. When the block of code that directly follows it terminates, either normally or because of an exception, the close methods of the BufferedWriter and ZipFile objects are automatically called in this order. Note that the close methods of resources are called in the opposite order of their creation.</p><p>在这个例子中，try-with-resources语句包含了两个用分号隔开的声明语句：<code>ZipFile</code>和<code>BufferedWriter</code>。当紧跟着这个语句的代码块结束时，不管是正常结束还是因为发生异常，BufferedWriter和ZipFile的close方法都会被自动地按顺序调用。注意这些resources的close方法的调用顺序和它们的创建语句顺序相反。</p><p>The following example uses a try-with-resources statement to automatically close a <code>java.sql.Statement</code> object:</p><p>下面的这个例子使用try-with-resouces语句自动关闭一个<code>java.sql.Statement</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void viewTable(Connection con) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    String query = &quot;select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES&quot;;</span><br><span class="line"></span><br><span class="line">    try (Statement stmt = con.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">      ResultSet rs = stmt.executeQuery(query);</span><br><span class="line"></span><br><span class="line">      while (rs.next()) &#123;</span><br><span class="line">        String coffeeName = rs.getString(&quot;COF_NAME&quot;);</span><br><span class="line">        int supplierID = rs.getInt(&quot;SUP_ID&quot;);</span><br><span class="line">        float price = rs.getFloat(&quot;PRICE&quot;);</span><br><span class="line">        int sales = rs.getInt(&quot;SALES&quot;);</span><br><span class="line">        int total = rs.getInt(&quot;TOTAL&quot;);</span><br><span class="line">        System.out.println(coffeeName + &quot;, &quot; + supplierID + &quot;, &quot; + price +</span><br><span class="line">                           &quot;, &quot; + sales + &quot;, &quot; + total);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      JDBCTutorialUtilities.printSQLException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The resource <code>java.sql.Statement</code> used in this example is part of the JDBC 4.1 and later API.</p><p>这个例子中的java.sql.Statement使用的是JDBC4.1及之后版本的API。</p><p><strong>Note</strong>: A <code>try-with-resources</code> statement can have catch and finally blocks just like an ordinary try statement. In a try-with-resources statement, any catch or finally block is run after the resources declared have been closed.</p><p><strong>注意</strong>：一个<code>try-with-resources</code>语句中也可以像单个try语句一样拥有catch和finally语句块。在一个try-with-resources语句中，任何catch或者finally语句块将在resources打开的资源被关闭后执行。</p><h2 id="Suppressed-Exceptions"><a href="#Suppressed-Exceptions" class="headerlink" title="Suppressed Exceptions"></a>Suppressed Exceptions</h2><p>An exception can be thrown from the block of code associated with the try-with-resources statement. In the example <code>writeToFileZipFileContents</code>, an exception can be thrown from the try block, and up to two exceptions can be thrown from the try-with-resources statement when it tries to close the <code>ZipFile</code> and <code>BufferedWriter</code> objects. If an exception is thrown from the try block and one or more exceptions are thrown from the try-with-resources statement, then those exceptions thrown from the try-with-resources statement are suppressed, and the exception thrown by the block is the one that is thrown by the <code>writeToFileZipFileContents</code> method. You can retrieve these suppressed exceptions by calling the <code>Throwable.getSuppressed</code> method from the exception thrown by the try block.</p><p>与try-with-resources有联系的代码块能抛出异常。在例子<code>writeToFileZipFileContents</code>中，try后的语句块中可能抛出异常，而且当试图关闭<code>ZipFile</code>和<code>BufferedWriter</code>对象时，try-with-resouces语句中可能抛出多达两个异常。如果有一个来自try语句块的异常和多个来自try-with-resources语句的异常，那么来自try-with-resources语句中的异常抛出会被抑制，块中的那个异常会被这个方法抛出。你可以通过调用<code>Throwable.getSuppressed</code>方法来获得那些被try块抑制的异常。</p><h2 id="Classes-That-Implement-the-AutoCloseable-or-Closeable-Interface"><a href="#Classes-That-Implement-the-AutoCloseable-or-Closeable-Interface" class="headerlink" title="Classes That Implement the AutoCloseable or Closeable Interface"></a>Classes That Implement the AutoCloseable or Closeable Interface</h2><p>See the Javadoc of the <code>AutoCloseable</code> and <code>Closeable</code> interfaces for a list of classes that implement either of these interfaces. The Closeable interface extends the AutoCloseable interface. The close method of the Closeable interface throws exceptions of type IOException while the close method of the AutoCloseable interface throws exceptions of type Exception. Consequently, subclasses of the AutoCloseable interface can override this behavior of the close method to throw specialized exceptions, such as IOException, or no exception at all.</p><p>查看Javadoc可以找到实现了<code>AutoCloseable</code>和<code>Closeable</code>之一的接口的类列表。Closeable接口继承自AutoCloseable接口。Closeable接口中的close方法抛出的是IOException类型的异常，而AutoCloseable接口中抛出的是Exception类型的异常。因此，实现AutoCloseable接口的类可以重写这个close方法让它更加具体，例如IOException或者不抛出异常。</p><p>PS：英文水平有限，只能做到把文章的意思用中文复述了一遍。也没有加一些自己的理解。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态内部类</title>
      <link href="/2018/02/08/180208/"/>
      <content type="html"><![CDATA[<blockquote><p> 越学习，越觉无知                                        ——鲁迅《没说过》<br><a id="more"></a></p></blockquote><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>昨晚在寝室翻书的时候，看到《Effective Java》中有提到，当遇到多个构造器参数很多，而且存在许多可选域的情况下，即使是使用重叠构造器也会十分麻烦，而如果使用JavaBean的setter方式，又不能满足一些类中的值初始化后不能修改的性质要求。</p><p>书里提到了一种使用Builder构建器的方式，使用静态内部类来简化多可选参数的初始化过程。对部分内容进行简化后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BuilderTest &#123;</span><br><span class="line">private final int var1;</span><br><span class="line">private final int var2;</span><br><span class="line"></span><br><span class="line">private BuilderTest(Builder builder)&#123;</span><br><span class="line">this.var1 = builder.var1;</span><br><span class="line">this.var2 = builder.var2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class Builder&#123;</span><br><span class="line">//必须项</span><br><span class="line">private final int var1;</span><br><span class="line">//可选项</span><br><span class="line">private int var2 = 0;</span><br><span class="line"></span><br><span class="line">public Builder(int var1)&#123;</span><br><span class="line">this.var1 = var1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Builder setVar2(int var2)&#123;</span><br><span class="line">this.var2 = var2;</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BuilderTest build()&#123;</span><br><span class="line">return new BuilderTest(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这其实就是设计模式中提到的Builder模式，将一个类的构建过程从这个类中剥离出来，虽然这个例子里是用的静态内部类实现，但是完全可以新建一个外部类来完成构建的工作。甚至可以将构建器定义为接口来使用。</p><p>使用了构建器模式创建对象的实例就可以通过方法链的方式进行属性值的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BuilderTest bt = new BuilderTest.Builder(5).setVar2(3).build();</span><br><span class="line">System.out.println(&quot;var1: &quot; + bt.var1);</span><br><span class="line">System.out.println(&quot;var2: &quot; + bt.var2);</span><br></pre></td></tr></table></figure><p>输出的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1: 5</span><br><span class="line">var2: 3</span><br></pre></td></tr></table></figure></p><p>上面的那个方法链写出来以后是不是觉得有点眼熟？没错，JDK8对集合进行增强操作的Stream API，就应该是使用了这种设计模式，当然内部的数据处理的实现比起上面这个例子是要复杂很多的。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>当学到这里的时候，我产生了一些疑惑。虽然现在解决以后觉得当时的自己很蠢，但是还是想把这些想法记录下来。</p><p>疑惑的点在于静态内部类的static关键字。之前知道使用static关键字修饰变量、代码块、方法的一些用途，就是当这些东西被static关键字修饰以后都会脱离实例对象成为类变量或类方法。</p><p>而如果一个类被声明为static的会发生什么，这一点并不清楚，因为类只有是内部类的这一种情况下才允许使用static进行修饰。那么这个static类和其他的static修饰的东西在使用上有什么不同？为什么还是要和其他类一样实例化，既然同样也需要实例化那么它和非静态内部类的区别在哪？它的生命周期有范围在哪？</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>带着这些疑问我去看了很多资料和博客，不过很多博客只是提到了静态内部类和非静态内部类的区别，并没有提到更多的东西。而这两者的区别就在于和外部类是否有联系，非静态内部类实例化后会有一个指向外部类的指针。而静态内部类实例化时不会产生指向外部类的指针，单独对它的外部类进行实例化时静态内部类也不会被实例化，两者之间虽然一个是外部类一个是内部类但是感觉上好像毫无联系。</p><p>正是因为不依赖于外部类这个特性，就可以避免无法及时被GC回收而导致的内存泄漏的问题。</p><p>从虚拟机的角度来看，被static修饰的内容会被装载到方法区的静态区，对于普通的静态区中的内容，它可以在类没有实例化时就能够被指针指向，也就表现出属于类而不属于实例的特性。根据这个特点我认为静态类也是这样的一种特性，虽然内部类是静态的，但是里面的变量和方法并不是静态的，同样需要被实例化以后将对象放在堆中才能使用，而static这个关键字是为了在外部类不被实例化时就能够被指针引用，从而实例化这个内部类而不用经过外部类。（不知道自己这个理解对不对）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样一看的话，其实静态内部类就很好理解了，它就是一个嵌套在类内部的顶层类，和普通的类一样，不过因为定义在其他类的内部所以需要使用static修饰使其对虚拟机可见，在实例化时不用依赖于外部类的实例对象。使用场景有限，通常是为了方便分包而使用。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>静态内部类内静态变量的访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BuilderTest &#123;</span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    //在静态内部类中声明一个静态变量</span><br><span class="line">    public static class Builder&#123;</span><br><span class="line">    public static int TEST = 22;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//两种方式都能访问到TEST这个变量</span><br><span class="line">System.out.println(&quot;BuilderTest.Builder.TEST:&quot; + BuilderTest.Builder.TEST);</span><br><span class="line">System.out.println(&quot;Builder.TEST:&quot; + Builder.TEST);</span><br></pre></td></tr></table></figure></p><p>以及静态内部类的其他不同叫法：</p><p>《Effective Java》里称其为静态成员类(static member class)，书里提到当不需要指向其外部类的实例，就应该使用静态成员类。</p><p>oracle官方文档里称作Static Nested Classes（静态嵌套类），文档写到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, to create an object for the static nested class, use this syntax:</span><br><span class="line"></span><br><span class="line">OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态内部类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lambda表达式和函数式接口</title>
      <link href="/2018/01/29/180129/"/>
      <content type="html"><![CDATA[<blockquote><p>刚进公司时，公司正处于由JDK7换用JDK8的时间短，之所以更换JDK版本，听说是公司业务中需要用到JDK8的一些新特性。鉴于我现在也无事可做，姑且来学习总结一下JDK8的一些特性吧。水平有限，这篇勉强算是对他人博客上零散内容的一个总结。<br><a id="more"></a></p></blockquote><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><p>Lambda表达式 匿名函数，当需要一个函数而又不想给他一个命名时，在java中，对于那些只使用一次的方法使用这种方式，能够减少命名上的负担。</p><p>允许将行为传入函数，取代匿名类。很经典的就是一个实现Runnable接口的例子，之前很长一段时间用的是匿名内部类，现在有了lambda表达式来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用匿名内部类</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;The old runable now is using!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">//使用lambda表达式</span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;It&apos;s a lambda function!&quot;)).start();</span><br></pre></td></tr></table></figure><p>减少了很多代码量，也使得代码结构更加清晰。</p><p>允许使用函数式风格编程，将函数当成参数传递给某个方法，或者把代码本身当作数据处理</p><p>结构写法上，lambda表达式由三部分组成： (参数列表)，符号 -&gt; ，函数体（多个语句时加上{}）。可以访问类的成员变量和局部变量，但是会转为final。</p><p>具体的一些匿名函数的使用，由于不太能用到所以不过多说明，仅举部分例子来作为使用时写法的参考，以集合类的遍历为例，虽然用之前的写法也不复杂。之所以选择集合类就是因为很熟悉，不用写原先的遍历方法出来，也能很好的对比两种写法的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//List的遍历</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">list.forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">//Map的遍历</span><br><span class="line">LinkedHashMap&lt;Integer,Integer&gt; lhm = new LinkedHashMap&lt;&gt;();</span><br><span class="line">lhm.put(1, 4);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">lhm.forEach((k,v) -&gt; System.out.println(&quot;key:&quot; + k + &quot; value:&quot; + v));</span><br></pre></td></tr></table></figure><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><p>函数式接口是SAM（Single Abstract Method ）类型的接口，是为了让现有功能能和Lambda表达式能够良好兼容所想出的方法。</p><p>定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个lambda表达式作为参数。换个角度说就是，当我们调用一个方法，可以传入lambda表达式作为参数，那么这个方法的参数类型，必定是一个函数式的接口。</p><p>就是指<strong>只有一个函数</strong>的接口，这样的接口可以被隐式转换为Lambda表达式。例如，<code>java.lang.Runnable</code> 和 <code>java.util.concurrent.Callable</code>等。</p><p>但是函数接口代码层面十分脆弱，只要这个接口中有其他的函数就会编译失败，为了解决函数接口在实际使用过程中的脆弱性。采用显式说明的方式，jdk8提供了一个<code>@FunctionalInterface</code>这个注解来进行声明。</p><p>不过默认方法和静态方法不会破环函数式接口的定义。</p><p>举上面提到的两个jdk中代码的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个都是函数式接口的写法，然后我们来对比一下使用lambda和不使用lambda表达式的写法差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//不使用Lambda表达式时</span><br><span class="line">Runnable runnable1=new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;RunningwithoutLambda&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//使用Lambda表达式的写法</span><br><span class="line">Runnable runnable2=()-&gt;&#123;</span><br><span class="line">    System.out.println(&quot;RunningfromLambda&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><p>其他什么predicate，stream之类的以后有机会有时间再来补充讨论。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习AOP时的一个问题</title>
      <link href="/2018/01/25/180125/"/>
      <content type="html"><![CDATA[<blockquote><p>这几天在公司看项目代码，翻到了aop的部分，本着学习的想法看了下使用AspectJ实现对日志的管理。但是在看这段代码的时候有一个问题一直困扰着我，就是代码的执行顺序。<br><a id="more"></a></p></blockquote><h2 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h2><p><code>@Around</code>这个注解的作用之类的就不在这里介绍了，只说其中的一个问题，使用<code>ProceedingJoinPoint</code>类获得切入点之后，用<code>proceed()</code>方法执行被切部分的代码。</p><p>问题就在这里，公司的代码中这个Advice方法具有一个Object的返回值，是proceed()方法调用后的返回值，那么如果在被切的类中，调用了被切方法的返回值，因为赋值操作和切面操作都是在方法之后执行，那么谁会更先执行呢？</p><p>在验证之前先说个推论吧。如果赋值语句先执行那么aop方法中的返回值将毫无意义，那么方法就可以改为void的返回值类型。如果around是在编译时将目标方法包裹住，是对目标方法的一种编译时内容扩充，那么对于aop方法，就应该记录proceed方法的返回值并返回。由于around增强具有修改参数这个功能，我比较倾向于第二种，能够获得返回值甚至进行修改的看法。</p><blockquote><p>说到底，能有这种困扰还是因为当初没有好好学习aop的内容，加上没有实际项目和具体问题来深入研究。现在书也还了，图书馆也关门了，只能依靠互联网了。</p></blockquote><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h4 id="advice-通知"><a href="#advice-通知" class="headerlink" title="advice 通知"></a>advice 通知</h4><p>通知感觉可以看作是切面需要完成的工作，这里面就包括了之前有所了解的五种通知类型。其他四种，before，after，after-returning，after-throwing都不会关心你的返回值。</p><h4 id="pointcut-切点"><a href="#pointcut-切点" class="headerlink" title="pointcut 切点"></a>pointcut 切点</h4><p>切点定义的是执行通知的连接点，因为一个通知可能不需要通知所有的连接点，相当于定位操作。</p><h4 id="join-point-连接点"><a href="#join-point-连接点" class="headerlink" title="join point 连接点"></a>join point 连接点</h4><p>连接点通俗一点的说法就是能够执行通知的时间点。</p><blockquote><p>其他术语不介绍了，慢慢看</p></blockquote><p>根据介绍，确实是通过包裹住目标方法的方式，实现织入。那么就可以开始写代码证明了。</p><hr><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>首先找一个返回值不为void的方法，这里我用的是自己之前一个项目中查找用户实体的service。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer find(String id);</span><br></pre></td></tr></table></figure></p><p>这个方法返回的是自己定义的一个Customer类型的对象，创建一个aop的切面来包围这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* com.px.service.*Service.find(..))&quot;)</span><br><span class="line">private void aspectjMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Around(value = &quot;aspectjMethod()&quot;)</span><br><span class="line">public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable&#123;</span><br><span class="line">    logger.info(&quot;before method&quot;);</span><br><span class="line">    Object returnValue = pjp.proceed();</span><br><span class="line">    logger.info(&quot;after method&quot;);</span><br><span class="line">    logger.info(&quot;returnClass: ---&gt;&quot; + returnValue.getClass().toString());</span><br><span class="line">    Customer customer = (Customer) returnValue;</span><br><span class="line">    logger.info(customer.toString());</span><br><span class="line">    customer.setName(&quot;Armourr&quot;);</span><br><span class="line">    return customer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中实现对目标方法的包围，执行目标方法后调用返回值<code>returnValue.getClass().toString()</code>得到返回对象的具体类名，然后将这个对象强制转换成Customer类型，打印相关信息并修改这个对象的部分信息，将修改后的对象作为返回值返回。</p><p>之后编写测试用例，执行service中的方法，打印返回值的相关内容信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void aopTest()&#123;</span><br><span class="line">    String id = &quot;1026&quot;;</span><br><span class="line">    Customer customer = customerService.find(id);</span><br><span class="line">    logger.info(&quot;return value: -----&gt;&quot; + customer.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终控制台输出的log信息为如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] before method</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO] after method</span><br><span class="line">[INFO] returnClass: ---&gt;class com.px.entity.Customer</span><br><span class="line">[INFO] Customer&#123;id=&apos;1026&apos;, name=&apos;customer25&apos;, gender=&apos;female&apos;, phone=&apos;134856225&apos;, email=&apos;customer25@163.com&apos;, description=&apos;hello world!&apos;&#125;</span><br><span class="line">[INFO] return value: -----&gt;Customer&#123;id=&apos;1026&apos;, name=&apos;Armourr&apos;, gender=&apos;female&apos;, phone=&apos;134856225&apos;, email=&apos;customer25@163.com&apos;, description=&apos;hello world!&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>通过观察日志信息不难发现，find方法执行后获得的返回值是已经被aop方法修改过的。因此，可以得出程序执行到切点时，会按照aop中的代码执行相关的aop操作，之后才会返回程序原来的部分继续执行。</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedHashMap学习笔记</title>
      <link href="/2018/01/23/180123/"/>
      <content type="html"><![CDATA[<blockquote><p>前几天看到一篇关于面试问题的博客，里面提到LinkedHashMap和TreeMap区别于HashMap的地方有一点就是是否有序，当时不甚明白，因为觉得LinkedHashMap用的是链表结构的，不知道是如何实现有序的，所以去看了看源码和一些文章。<br><a id="more"></a></p></blockquote><hr><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>LinkedHashMap继承自HashMap，内部类Entry也是继承自HashMap.Node&lt;K,V&gt;，但是里面定义了两个独有的元素：<code>Entry&lt;K,V&gt; before, after;</code>，有序就是通过这两个元素来实现。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>LinkedHashMap实现的基本思想就是对<code>多态</code>的使用。它许多方法都是使用的HashMap中已有的方法，通过对方法中调用的子方法进行复写，通过动态绑定，实现方法重用。</p><h5 id="1-内部属性"><a href="#1-内部属性" class="headerlink" title="1.内部属性"></a>1.内部属性</h5><p>在我所看的1.8版本的jdk中，定义了一个静态节点元素Entry，以及这个链表的头元素head和尾元素tail，这两个元素是用来方便对链表进行操作的。</p><p>此外还有一个特有的属性<code>final boolean accessOrder</code>，这是一个用来确定LinkedHashMap的顺序的值，若初始化时确定为false代表按照插入顺序，true表示按照最后操作顺序。在调用构造方法进行初始化时，如果没有指定这个值，默认都是为false。而且构造方法都是调用父类的构造方法来实现的。</p><h5 id="2-有序实现"><a href="#2-有序实现" class="headerlink" title="2.有序实现"></a>2.有序实现</h5><p>我们在此先不讨论accessOrder为true的情况，单说按照插入顺序访问的实现方式。</p><p>刚才有提到Entry节点比父类中的多了两个指针，before和after，看到这两个指针时大概就能想到实现按照插入顺序的访问应该是在插入节点时记录他的before和after两个值。知道了它的大概方式，我们来找它的具体实现。</p><p>观察源码可以发现LinkedHashMap中关于元素存取，值重写了get方法，并没有重写put方法。之所以会重写get方法是因为要实现按照元素最后访问顺序的有序方式。我们来到父类HashMap中,当桶中相应位置没有元素时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure></p><p>当hash值对应位置有元素存在时，且新元素的key不跟其他元素相同时，在链表末尾将新元素加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line">if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">else &#123;</span><br><span class="line">    for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        if ((e = p.next) == null) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, null);</span><br><span class="line">            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            break;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察代码发现新节点的加入使用的是newNode方法，这个方法在子类中是重写了的，所以会调用子类中的newNode方法，所以我们又回到了LinkedHashMap中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法会new一个Entry，通过linkNodeLast将其顺序确定下来，然后返回一个Entry类型的元素。所以其实有序的实现是放在了linkNodeLast这个方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用之前定义的tail来操作，新建一个last元素保存tail的引用，将传入的元素设置为最后一个，然后确定两个元素之间的指向问题。这样就将插入的顺序记录了下来。</p><p>另外，accessOrder=true的情况也是对这个指针的指向的修改，通过将最后访问的节点改到tail的位置，本文不作深入的探讨。</p><h5 id="3-迭代器遍历"><a href="#3-迭代器遍历" class="headerlink" title="3.迭代器遍历"></a>3.迭代器遍历</h5><p>LinkedHashMap内部定义了一个内部抽象类，LinkedHashIterator，里面定义了相关的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历时使用after来改变指向，就能够按照顺序来访问了。它的子类有LinkedKeyIterator，LinkedValueIterator，LinkedEntryIterator三个，都实现了Iterator接口，使用时能够自动根据数据类型动态绑定相应的方法进行遍历的实现。</p>]]></content>
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedHashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>淮中晚泊犊头</title>
      <link href="/2018/01/01/title/"/>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="淮中晚泊犊头"><a href="#淮中晚泊犊头" class="headerlink" title="淮中晚泊犊头"></a>淮中晚泊犊头</h2><p><br></p><p>苏舜钦</p><p>春阴垂野草青青，时有幽花一树明。</p><p>晚泊孤舟古祠下，满川风雨看潮生。</p>]]></content>
      
      <categories>
          
          <category> 诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
